<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TaxiTracker 2 - Suivi Intelligent</title>
    <link rel="manifest" href="./manifest.json" />
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      rel="manifest"
      href="data:application/json;base64,eyJuYW1lIjoiVGF4aVRyYWNrZXIiLCJzaG9ydF9uYW1lIjoiVGF4aVRyYWNrZXIiLCJzdGFydF91cmwiOiIvIiwiZGlzcGxheSI6InN0YW5kYWxvbmUiLCJiYWNrZ3JvdW5kX2NvbG9yIjoiIzFmMjkzNyIsInRoZW1lX2NvbG9yIjoiIzM5OGVmNCIsImljb25zIjpbeyJzcmMiOiJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlOVEV5SWlCb1pXbG5hSFE5SWpVeE1pSWdkbWxsZDBKdmVEMGlNQ0F3SURVM01pQTFNVElpSUdacGJHdzlJaU16T1RobFpqUWlQanh5WldOMElIZzlJakV3TUNJZ2VUMGlNVEF3SWlCM2FXUjBhRDBpTXpFeUlpQm9aV2xuYUhROUlqTXhNaUlnY25nOUlqRTJJaUJtYVd4c1BTSWpabVptSWk4K1BDOXpkbWMrIiwic2l6ZXMiOiI1MTJ4NTEyIiwidHlwZSI6ImltYWdlL3N2Zyt4bWwifV19"
    />
    <!-- Leaflet pour les cartes interactives -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
      (function () {
        function c() {
          var b = a.contentDocument || a.contentWindow.document;
          if (b) {
            var d = b.createElement("script");
            d.innerHTML =
              "window.__CF$cv$params={r:'98827419d400025f',t:'MTc1OTM4OTc5Ny4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";
            b.getElementsByTagName("head")[0].appendChild(d);
          }
        }
        if (document.body) {
          var a = document.createElement("iframe");
          a.height = 1;
          a.width = 1;
          a.style.position = "absolute";
          a.style.top = 0;
          a.style.left = 0;
          a.style.border = "none";
          a.style.visibility = "hidden";
          document.body.appendChild(a);
          if ("loading" !== document.readyState) c();
          else if (window.addEventListener)
            document.addEventListener("DOMContentLoaded", c);
          else {
            var e = document.onreadystatechange || function () {};
            document.onreadystatechange = function (b) {
              e(b);
              "loading" !== document.readyState &&
                ((document.onreadystatechange = e), c());
            };
          }
        }
      })();
    </script>
    <style>
      .zoom-btn {
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .zoom-btn:hover {
        transform: scale(1.1);
      }
      .zoom-preset {
        transition: all 0.2s ease;
      }
      .zoom-preset:hover {
        transform: translateY(-1px);
      }
      .zoom-preset.active {
        background-color: #10b981;
      }
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap");
      body {
        font-family: "Inter", sans-serif;
        box-sizing: border-box;
      }
      .gradient-bg {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      }
      .glass {
        backdrop-filter: blur(10px);
        background: rgba(255, 255, 255, 0.1);
      }
      .pulse-dot {
        animation: pulse 2s infinite;
      }
      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }
      .camera-preview {
        aspect-ratio: 4/3;
        background: #1f2937;
        border-radius: 12px;
        position: relative;
        overflow: hidden;
      }
      .skeleton-overlay {
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 0, 0.3);
      }
      .gps-indicator {
        animation: gps-pulse 1.5s infinite;
      }
      @keyframes gps-pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }
    </style>
  </head>
  <body class="bg-gray-900 text-white min-h-screen">
    <!-- Header -->
    <header class="gradient-bg p-4 shadow-lg">
      <div class="flex items-center justify-between max-w-md mx-auto">
        <div class="flex items-center space-x-3">
          <div
            class="w-10 h-10 bg-white rounded-lg flex items-center justify-center"
          >
            <span class="text-2xl">üöñ</span>
          </div>
          <div>
            <h1 class="text-xl font-bold">TaxiTracker</h1>
            <p class="text-sm opacity-80">Chauffeur: Mbemba Jean</p>
          </div>
        </div>
        <div class="flex items-center space-x-2">
          <div id="gps-indicator" class="w-3 h-3 bg-red-400 rounded-full"></div>
          <div class="pulse-dot w-3 h-3 bg-green-400 rounded-full"></div>
          <span class="text-sm">En ligne</span>
        </div>
      </div>
    </header>

    <!-- Main Content -->
    <main class="max-w-md mx-auto p-4 space-y-6">
      <!-- GPS Status Card -->
      <div class="bg-gray-800 rounded-xl p-4 shadow-lg">
        <div class="flex items-center justify-between mb-2">
          <span class="font-medium">üìç Position GPS</span>
          <span id="gps-status" class="text-red-400 text-sm">D√©sactiv√©</span>
        </div>
        <div class="grid grid-cols-2 gap-4 text-sm">
          <div>
            <p class="text-gray-400">Pr√©cision</p>
            <p id="gps-accuracy" class="font-bold">-</p>
          </div>
          <div>
            <p class="text-gray-400">Vitesse</p>
            <p id="gps-speed" class="font-bold">-</p>
          </div>
        </div>
        <div class="mt-2">
          <p class="text-gray-400 text-xs">
            Points collect√©s: <span id="points-count">0</span>
          </p>
          <p class="text-gray-400 text-xs">
            Derni√®re position: <span id="last-position">-</span>
          </p>
        </div>
      </div>

      <!-- Status Card -->
      <div class="bg-gray-800 rounded-xl p-6 shadow-lg">
        <div class="flex items-center justify-between mb-4">
          <h2 class="text-lg font-semibold">Statut Actuel</h2>
          <span
            id="status-badge"
            class="px-3 py-1 bg-yellow-500 text-black rounded-full text-sm font-medium"
            >Libre</span
          >
        </div>
        <div class="grid grid-cols-2 gap-4 text-center">
          <div>
            <p class="text-2xl font-bold text-blue-400" id="daily-earnings">
              12,500
            </p>
            <p class="text-sm text-gray-400">FCFA aujourd'hui</p>
          </div>
          <div>
            <p class="text-2xl font-bold text-green-400" id="trip-count">8</p>
            <p class="text-sm text-gray-400">Courses</p>
          </div>
        </div>
      </div>

      <!-- Action Buttons -->
      <div class="space-y-3">
        <button
          id="start-day-btn"
          class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-4 px-6 rounded-xl transition-colors shadow-lg"
        >
          ‚ñ∂Ô∏è D√©marrer la journ√©e
        </button>

        <button
          id="declare-trip-btn"
          class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-4 px-6 rounded-xl transition-colors shadow-lg opacity-50 cursor-not-allowed"
          disabled
        >
          ‚ûï D√©clarer une course
        </button>

        <button
          id="pause-btn"
          class="w-full bg-orange-600 hover:bg-orange-700 text-white font-semibold py-4 px-6 rounded-xl transition-colors shadow-lg opacity-50 cursor-not-allowed"
          disabled
        >
          ‚è∏Ô∏è Pause
        </button>
      </div>

      <!-- Trip Declaration Modal -->
      <div
        id="trip-modal"
        class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center p-4 z-50"
      >
        <div class="bg-gray-800 rounded-xl p-6 w-full max-w-sm">
          <h3 class="text-xl font-bold mb-4">D√©clarer une course</h3>
          <div class="space-y-4">
            <div>
              <label class="block text-sm font-medium mb-2"
                >Montant (FCFA)</label
              >
              <input
                type="number"
                id="trip-amount"
                class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white"
                placeholder="ex: 1500"
              />
              <div class="mt-1">
                <p class="text-xs text-blue-400">
                  Prix estim√©:
                  <span id="estimated-price">Calcul√© automatiquement</span>
                </p>
              </div>
            </div>
            <div>
              <label class="block text-sm font-medium mb-2"
                >Nombre de passagers</label
              >
              <select
                id="passenger-count"
                class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white"
              >
                <option value="1">1 passager</option>
                <option value="2">2 passagers</option>
                <option value="3">3 passagers</option>
                <option value="4">4 passagers</option>
              </select>
            </div>
            <div class="flex space-x-3">
              <button
                id="cancel-trip"
                class="flex-1 bg-gray-600 hover:bg-gray-700 text-white py-2 px-4 rounded-lg transition-colors"
              >
                Annuler
              </button>
              <button
                id="start-trip"
                class="flex-1 bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded-lg transition-colors"
              >
                D√©marrer course
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Camera Verification Modal -->
      <div
        id="camera-modal"
        class="fixed inset-0 bg-black bg-opacity-90 hidden items-center justify-center p-4 z-50"
      >
        <div class="bg-gray-800 rounded-xl p-6 w-full max-w-sm">
          <h3 class="text-xl font-bold mb-4 text-center">üì∏ V√©rification IA</h3>
          <div class="camera-preview mb-4">
            <video
              id="camera-feed"
              class="w-full h-full object-cover rounded-lg"
              autoplay
              muted
            ></video>
            <div class="skeleton-overlay hidden" id="skeleton-overlay">
              <div class="flex items-center justify-center h-full">
                <div class="text-center">
                  <div class="w-16 h-16 mx-auto mb-2">
                    <!-- Skeleton figure -->
                    <svg
                      viewBox="0 0 100 100"
                      class="w-full h-full text-blue-400"
                    >
                      <circle cx="50" cy="20" r="8" fill="currentColor" />
                      <line
                        x1="50"
                        y1="28"
                        x2="50"
                        y2="70"
                        stroke="currentColor"
                        stroke-width="3"
                      />
                      <line
                        x1="35"
                        y1="40"
                        x2="65"
                        y2="40"
                        stroke="currentColor"
                        stroke-width="3"
                      />
                      <line
                        x1="50"
                        y1="70"
                        x2="35"
                        y2="90"
                        stroke="currentColor"
                        stroke-width="3"
                      />
                      <line
                        x1="50"
                        y1="70"
                        x2="65"
                        y2="90"
                        stroke="currentColor"
                        stroke-width="3"
                      />
                    </svg>
                  </div>
                  <p class="text-sm text-blue-400">Analyse en cours...</p>
                </div>
              </div>
            </div>
          </div>
          <div class="text-center">
            <p id="verification-message" class="text-lg font-medium mb-2">
              V√©rification dans <span id="countdown">5</span>s...
            </p>
            <p class="text-sm text-gray-400">
              Positionnez-vous bien dans le cadre
            </p>
          </div>
        </div>
      </div>

      <!-- Verification Result Modal -->
      <div
        id="result-modal"
        class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center p-4 z-50"
      >
        <div class="bg-gray-800 rounded-xl p-6 w-full max-w-sm text-center">
          <div id="result-icon" class="text-6xl mb-4">‚úÖ</div>
          <h3 id="result-title" class="text-xl font-bold mb-2">
            V√©rification r√©ussie
          </h3>
          <p id="result-message" class="text-gray-400 mb-4">
            2 passagers d√©tect√©s - Conforme √† la d√©claration
          </p>
          <button
            id="close-result"
            class="w-full bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded-lg transition-colors"
          >
            Continuer
          </button>
        </div>
      </div>

      <!-- Current Trip Card -->
      <div
        id="current-trip"
        class="bg-gray-800 rounded-xl p-6 shadow-lg hidden"
      >
        <div class="flex items-center justify-between mb-4">
          <h3 class="text-lg font-semibold">Course en cours</h3>
          <span
            class="px-3 py-1 bg-green-500 text-white rounded-full text-sm font-medium"
            >Active</span
          >
        </div>
        <div class="grid grid-cols-2 gap-4 mb-4">
          <div>
            <p class="text-sm text-gray-400">Montant d√©clar√©</p>
            <p class="text-lg font-bold text-green-400" id="current-amount">
              -
            </p>
          </div>
          <div>
            <p class="text-sm text-gray-400">Distance GPS</p>
            <p class="text-lg font-bold text-blue-400" id="current-distance">
              0.0 km
            </p>
          </div>
        </div>
        <div class="grid grid-cols-2 gap-4 mb-4">
          <div>
            <p class="text-sm text-gray-400">Dur√©e</p>
            <p class="text-xl font-bold text-white" id="trip-duration">00:00</p>
          </div>
          <div>
            <p class="text-sm text-gray-400">Prix estim√©</p>
            <p
              class="text-lg font-bold text-yellow-400"
              id="estimated-current-price"
            >
              -
            </p>
          </div>
        </div>
        <button
          id="end-trip-btn"
          class="w-full bg-red-600 hover:bg-red-700 text-white font-semibold py-3 px-6 rounded-lg transition-colors"
        >
          Terminer la course
        </button>
      </div>

      <!-- Zone Status -->
      <div class="bg-gray-800 rounded-xl p-4 shadow-lg">
        <div class="flex items-center justify-between">
          <div class="flex items-center space-x-3">
            <span class="text-2xl">üìç</span>
            <div>
              <p class="font-medium">Zone Pointe-Noire</p>
              <p class="text-sm text-green-400">Dans la zone autoris√©e</p>
            </div>
          </div>
          <div class="w-3 h-3 bg-green-400 rounded-full"></div>
        </div>
      </div>
      <!-- Historique des courses -->
      <div class="bg-gray-800 rounded-xl p-4 shadow-lg">
        <div class="flex items-center justify-between mb-4">
          <div class="flex items-center space-x-3">
            <span class="text-2xl">üìã</span>
            <div>
              <p class="font-medium">Historique</p>
              <p class="text-sm text-gray-400" id="trip-history-count">
                0 courses
              </p>
            </div>
          </div>
          <button
            id="refresh-history-btn"
            class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded-lg text-sm"
          >
            üîÑ Actualiser
          </button>
        </div>
        <div id="trip-history-list" class="space-y-2 max-h-60 overflow-y-auto">
          <p class="text-gray-500 text-sm text-center py-4">
            Aucune course enregistr√©e
          </p>
        </div>
      </div>

      <!-- Score de confiance -->
      <div class="bg-gray-800 rounded-xl p-4 shadow-lg">
        <div class="flex items-center justify-between mb-2">
          <span class="font-medium">Score de confiance</span>
          <span id="trust-score" class="text-green-400 font-bold">100%</span>
        </div>
        <div class="w-full bg-gray-700 rounded-full h-2">
          <div
            id="trust-bar"
            class="bg-green-400 h-2 rounded-full"
            style="width: 100%"
          ></div>
        </div>
        <p class="text-xs text-gray-400 mt-1">
          Excellent comportement ce mois-ci
        </p>
      </div>

      <!-- Modal d√©tails de course -->
      <div
        id="trip-details-modal"
        class="fixed inset-0 bg-black bg-opacity-50 hidden z-50"
      >
        <div class="flex items-center justify-center min-h-screen p-4">
          <div
            class="bg-gray-900 rounded-xl p-6 max-w-4xl w-full max-h-[90vh] overflow-y-auto"
          >
            <!-- Header -->
            <div class="flex items-center justify-between mb-6">
              <h2 class="text-xl font-bold text-white">
                üìã D√©tails de la course
              </h2>
              <button
                id="close-trip-details"
                class="text-gray-400 hover:text-white text-2xl"
              >
                √ó
              </button>
            </div>

            <!-- Contenu principal -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
              <!-- Informations de la course -->
              <div class="space-y-4">
                <div class="bg-gray-800 rounded-lg p-4">
                  <h3 class="font-semibold text-white mb-3">
                    üí∞ Informations g√©n√©rales
                  </h3>
                  <div class="space-y-2 text-sm">
                    <div class="flex justify-between">
                      <span class="text-gray-400">Montant:</span>
                      <span
                        class="text-green-400 font-semibold"
                        id="detail-amount"
                        >-</span
                      >
                    </div>
                    <div class="flex justify-between">
                      <span class="text-gray-400">Passagers:</span>
                      <span class="text-white" id="detail-passengers">-</span>
                    </div>
                    <div class="flex justify-between">
                      <span class="text-gray-400">Zone:</span>
                      <span class="text-blue-400" id="detail-zone">-</span>
                    </div>
                    <div class="flex justify-between">
                      <span class="text-gray-400">Distance:</span>
                      <span class="text-white" id="detail-distance">-</span>
                    </div>
                    <div class="flex justify-between">
                      <span class="text-gray-400">Dur√©e:</span>
                      <span class="text-white" id="detail-duration">-</span>
                    </div>
                  </div>
                </div>

                <div class="bg-gray-800 rounded-lg p-4">
                  <h3 class="font-semibold text-white mb-3">üïê Horaires</h3>
                  <div class="space-y-2 text-sm">
                    <div class="flex justify-between">
                      <span class="text-gray-400">D√©but:</span>
                      <span class="text-white" id="detail-start-time">-</span>
                    </div>
                    <div class="flex justify-between">
                      <span class="text-gray-400">Fin:</span>
                      <span class="text-white" id="detail-end-time">-</span>
                    </div>
                    <div class="flex justify-between">
                      <span class="text-gray-400">Date:</span>
                      <span class="text-white" id="detail-date">-</span>
                    </div>
                  </div>
                </div>

                <div
                  class="bg-gray-800 rounded-lg p-4"
                  id="detail-alerts-section"
                  style="display: none"
                >
                  <h3 class="font-semibold text-red-400 mb-3">
                    ‚ö†Ô∏è Alertes d√©tect√©es
                  </h3>
                  <div id="detail-alerts-list" class="space-y-1 text-sm"></div>
                </div>
              </div>

              <!-- Carte de l'itin√©raire -->
              <div class="space-y-4">
                <div class="bg-gray-800 rounded-lg p-4">
                  <h3 class="font-semibold text-white mb-3">
                    üó∫Ô∏è Itin√©raire parcouru
                  </h3>
                  <div
                    id="trip-map"
                    class="w-full h-80 bg-gray-700 rounded-lg relative overflow-hidden"
                  >
                    <div
                      class="absolute inset-0 flex items-center justify-center text-gray-400"
                    >
                      <div class="text-center">
                        <div class="text-4xl mb-2">üó∫Ô∏è</div>
                        <p>Chargement de la carte...</p>
                      </div>
                    </div>
                  </div>
                </div>

                <div class="bg-gray-800 rounded-lg p-4">
                  <h3 class="font-semibold text-white mb-3">üìç Positions</h3>
                  <div class="space-y-2 text-sm">
                    <div>
                      <span class="text-gray-400">D√©part:</span>
                      <p class="text-green-400" id="detail-start-position">-</p>
                    </div>
                    <div>
                      <span class="text-gray-400">Arriv√©e:</span>
                      <p class="text-red-400" id="detail-end-position">-</p>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </main>

    <script>
      // ===== ENTIT√â USER =====
      class User {
        constructor(data = {}) {
          this.id = data.id || null;
          this.email = data.email || "";
          this.role = data.role || "driver"; // 'driver', 'owner', 'admin'
          this.nom = data.nom || "";
          this.prenom = data.prenom || "";
          this.age = data.age || null;
          this.phone = data.phone || "";
          this.createdAt = data.createdAt
            ? new Date(data.createdAt)
            : new Date();
        }

        toJSON() {
          return {
            id: this.id,
            email: this.email,
            role: this.role,
            nom: this.nom,
            prenom: this.prenom,
            age: this.age,
            phone: this.phone,
            createdAt: this.createdAt.toISOString(),
          };
        }

        static fromJSON(json) {
          if (!json) return null;
          return new User({
            id: json.id,
            email: json.email,
            role: json.role,
            nom: json.nom,
            prenom: json.prenom,
            age: json.age,
            phone: json.phone,
            createdAt: json.createdAt,
          });
        }
      }
      // ===== ENTIT√â DRIVER =====
      class Driver extends User {
        constructor(data = {}) {
          super(data);
          this.ownerId = data.ownerId || null;
          this.licenseNumber = data.licenseNumber || "";
          this.vehicleId = data.vehicleId || null;
        }

        toJSON() {
          return {
            ...super.toJSON(),
            ownerId: this.ownerId,
            licenseNumber: this.licenseNumber,
            vehicleId: this.vehicleId,
          };
        }

        static fromJSON(json) {
          if (!json) return null;
          return new Driver({
            id: json.id,
            email: json.email,
            role: json.role,
            nom: json.nom,
            prenom: json.prenom,
            age: json.age,
            phone: json.phone,
            ownerId: json.ownerId,
            licenseNumber: json.licenseNumber,
            vehicleId: json.vehicleId,
            createdAt: json.createdAt,
          });
        }
      }

      // ===== ENTIT√â OWNER =====
      class Owner extends User {
        constructor(data = {}) {
          super(data);
          this.companyName = data.companyName || "";
          this.taxId = data.taxId || "";
        }

        toJSON() {
          return {
            ...super.toJSON(),
            companyName: this.companyName,
            taxId: this.taxId,
          };
        }

        static fromJSON(json) {
          if (!json) return null;
          return new Owner({
            id: json.id,
            email: json.email,
            role: json.role,
            nom: json.nom,
            prenom: json.prenom,
            age: json.age,
            phone: json.phone,
            companyName: json.companyName,
            taxId: json.taxId,
            createdAt: json.createdAt,
          });
        }
      }

      // ===== ENTIT√âS M√âTIER =====

      // Entit√© Course
      class Trip {
        constructor(data = {}) {
          this.id = data.id || this._generateId();
          this.driverId = data.driverId || null;
          this.ownerId = data.ownerId || null;
          this.amount = data.amount || 0;
          this.passengers = data.passengers || 1;
          this.startPosition = data.startPosition || null; // { lat, lng, accuracy, timestamp }
          this.endPosition = data.endPosition || null;
          this.gpsPoints = data.gpsPoints || []; // [{ lat, lng, accuracy, timestamp }, ...]
          this.startTime = data.startTime
            ? new Date(data.startTime)
            : new Date();
          this.endTime = data.endTime ? new Date(data.endTime) : null;
          this.distance = data.distance || 0; // km
          this.duration = data.duration || 0; // ms
          this.zone = data.zone || "default";
          this.status = data.status || "active"; // active, completed, cancelled
          this.estimatedPrice = data.estimatedPrice || 0;
          this.fraudAlerts = Array.isArray(data.fraudAlerts)
            ? data.fraudAlerts
            : [];
          this.createdAt = data.createdAt
            ? new Date(data.createdAt)
            : new Date();
          this.updatedAt = data.updatedAt ? new Date(data.updatedAt) : null;
        }
        _generateId() {
          return `trip_${Date.now().toString(36)}${Math.random()
            .toString(36)
            .substr(2, 5)}`;
        }

        complete(endPosition, distance, duration) {
          this.endPosition = endPosition;
          this.endTime = Date.now();
          this.distance = distance;
          this.duration = duration;
          this.status = "completed";
          this.updatedAt = new Date().toISOString();
        }
        addFraudAlert(alert) {
          this.fraudAlerts.push({
            message: alert,
            timestamp: Date.now(),
          });
          this.updatedAt = new Date().toISOString();
        }
        // S√©rialisation pour stockage
        _serialize() {
          return {
            id: this.id,
            driverId: this.driverId,
            ownerId: this.ownerId,
            amount: this.amount,
            passengers: this.passengers,
            startPosition: this.startPosition,
            endPosition: this.endPosition,
            gpsPoints: this.gpsPoints,
            startTime: this.startTime.toISOString(),
            endTime: this.endTime ? this.endTime.toISOString() : null,
            distance: this.distance,
            duration: this.duration,
            zone: this.zone,
            status: this.status,
            estimatedPrice: this.estimatedPrice,
            fraudAlerts: this.fraudAlerts,
            createdAt: this.createdAt.toISOString(),
            updatedAt: this.updatedAt ? this.updatedAt.toISOString() : null,
          };
        }
        // D√©s√©rialisation depuis stockage
        static _deserialize(data) {
          return new Trip(data);
        }
        toJSON() {
          return this._serialize();
        }
      }

      // Entit√© Point GPS
      class GPSPoint {
        constructor(data = {}) {
          this.id = data.id || this._generateId();
          this.tripId = data.tripId || null;
          this.driverId = data.driverId || null;
          this.ownerId = data.ownerId || null;
          this.lat = data.lat || 0;
          this.lng = data.lng || 0;
          this.accuracy = data.accuracy || 0; // m√®tres
          this.speed = data.speed || 0; // m/s
          this.heading = data.heading || 0; // degr√©s
          this.altitude = data.altitude || 0;
          this.timestamp = data.timestamp
            ? new Date(data.timestamp)
            : new Date();
          this.provider = data.provider || "html5";
        }

        _generateId() {
          return `gps_${Date.now().toString(36)}${Math.random()
            .toString(36)
            .substr(2, 5)}`;
        }
        // S√©rialisation pour stockage
        _serialize() {
          return {
            id: this.id,
            tripId: this.tripId,
            driverId: this.driverId,
            ownerId: this.ownerId,
            lat: this.lat,
            lng: this.lng,
            accuracy: this.accuracy,
            speed: this.speed,
            heading: this.heading,
            altitude: this.altitude,
            timestamp: this.timestamp.toISOString(),
            provider: this.provider,
          };
        }

        // D√©s√©rialisation depuis stockage
        static _deserialize(data) {
          return new GPSPoint(data);
        }

        toJSON() {
          return this._serialize();
        }
      }
      // ===== ENTIT√â FRAUD ALERT =====
      class FraudAlert {
        constructor(data = {}) {
          this.id = data.id || this._generateId();
          this.tripId = data.tripId || null;
          this.driverId = data.driverId || null;
          this.ownerId = data.ownerId || null;
          this.type = data.type || "unknown"; // 'mismatch_declared_vs_detected', 'unauthorized_zone', etc.
          this.message = data.message || "";
          this.proofURL = data.proofURL || null; // URL vers image anonymis√©e
          this.timestamp = data.timestamp
            ? new Date(data.timestamp)
            : new Date();
          this.resolved = data.resolved || false;
          this.resolvedAt = data.resolvedAt ? new Date(data.resolvedAt) : null;
        }

        _generateId() {
          return `alert_${Date.now().toString(36)}${Math.random()
            .toString(36)
            .substr(2, 5)}`;
        }

        toJSON() {
          return {
            id: this.id,
            tripId: this.tripId,
            driverId: this.driverId,
            ownerId: this.ownerId,
            type: this.type,
            message: this.message,
            proofURL: this.proofURL,
            timestamp: this.timestamp.toISOString(),
            resolved: this.resolved,
            resolvedAt: this.resolvedAt ? this.resolvedAt.toISOString() : null,
          };
        }

        static fromJSON(json) {
          if (!json) return null;
          return new FraudAlert({
            id: json.id,
            tripId: json.tripId,
            driverId: json.driverId,
            ownerId: json.ownerId,
            type: json.type,
            message: json.message,
            proofURL: json.proofURL,
            timestamp: json.timestamp,
            resolved: json.resolved,
            resolvedAt: json.resolvedAt,
          });
        }
      }

      // ===== ENTIT√â PLANNING DE TRAVAIL =====
      class WorkSchedule {
        constructor(data = {}) {
          this.ownerId = data.ownerId || null;
          this.driverId = data.driverId || null;
          this.workStartHour = data.workStartHour || 8; // 8h
          this.workEndHour = data.workEndHour || 20; // 20h
          this.totalPauseMinutes = data.totalPauseMinutes || 120; // 2h
          this.toleranceMinutes = data.toleranceMinutes || 30; // ¬±30 min
          this.active = data.active !== false; // true par d√©faut
          this.createdAt = data.createdAt
            ? new Date(data.createdAt)
            : new Date();
          this.updatedAt = data.updatedAt ? new Date(data.updatedAt) : null;
        }

        toJSON() {
          return {
            ownerId: this.ownerId,
            driverId: this.driverId,
            workStartHour: this.workStartHour,
            workEndHour: this.workEndHour,
            totalPauseMinutes: this.totalPauseMinutes,
            toleranceMinutes: this.toleranceMinutes,
            active: this.active,
            createdAt: this.createdAt.toISOString(),
            updatedAt: this.updatedAt ? this.updatedAt.toISOString() : null,
          };
        }

        static fromJSON(json) {
          return json ? new WorkSchedule(json) : null;
        }
      }
      // ===== ENTIT√â JOURNAL DE LA JOURN√âE =====
      class DayLogEntry {
        constructor(data = {}) {
          this.id = data.id || this._generateId();
          this.driverId = data.driverId || appState.currentDriverId;
          this.ownerId = data.ownerId || appState.currentOwnerId;
          this.type = data.type; // 'start_day', 'end_day', 'pause_start', 'pause_end', 'trip_start', 'trip_end', 'activity_check'
          this.timestamp = data.timestamp
            ? new Date(data.timestamp)
            : new Date();
          this.metadata = data.metadata || {};
        }

        _generateId() {
          return `log_${Date.now().toString(36)}${Math.random()
            .toString(36)
            .substr(2, 5)}`;
        }

        toJSON() {
          return {
            id: this.id,
            driverId: this.driverId,
            ownerId: this.ownerId,
            type: this.type,
            timestamp: this.timestamp.toISOString(),
            metadata: this.metadata,
          };
        }

        static fromJSON(json) {
          return json ? new DayLogEntry(json) : null;
        }
      }
      // Entit√© Statistiques
      class DailyStats {
        constructor(data = {}) {
          this.id = data.id || this._generateId();
          this.driverId = data.driverId || null;
          this.ownerId = data.ownerId || null;
          this.date = data.date || new Date().toISOString().split("T")[0]; // YYYY-MM-DD
          this.totalEarnings = data.totalEarnings || 0;
          this.tripCount = data.tripCount || 0;
          this.totalDistance = data.totalDistance || 0;
          this.totalDuration = data.totalDuration || 0;
          this.averageTrip = data.averageTrip || 0;
          this.fraudAlertsCount = data.fraudAlertsCount || 0;
          this.zones = data.zones || {};
          this.createdAt = data.createdAt
            ? new Date(data.createdAt)
            : new Date();
          this.updatedAt = data.updatedAt ? new Date(data.updatedAt) : null;
        }

        _generateId() {
          return `stats_${this.date}_${this.driverId || "global"}`;
        }
        updateFromTrip(trip) {
          this.totalEarnings += trip.amount;
          this.tripCount += 1;
          this.totalDistance += trip.distance;
          this.totalDuration += trip.duration;
          this.averageTrip = this.totalEarnings / this.tripCount;
          this.fraudAlertsCount += trip.fraudAlerts.length;
          this.zones[trip.zone] = (this.zones[trip.zone] || 0) + 1;
          this.updatedAt = new Date();
        }
        // S√©rialisation pour stockage
        _serialize() {
          return {
            id: this.id,
            driverId: this.driverId,
            ownerId: this.ownerId,
            date: this.date,
            totalEarnings: this.totalEarnings,
            tripCount: this.tripCount,
            totalDistance: this.totalDistance,
            totalDuration: this.totalDuration,
            averageTrip: this.averageTrip,
            fraudAlertsCount: this.fraudAlertsCount,
            zones: this.zones,
            createdAt: this.createdAt.toISOString(),
            updatedAt: this.updatedAt ? this.updatedAt.toISOString() : null,
          };
        }

        // D√©s√©rialisation depuis stockage
        static _deserialize(data) {
          return new DailyStats(data);
        }
        toJSON() {
          return this._serialize();
        }
      }

      // ===== INTERFACES REPOSITORY =====

      // Interface Repository g√©n√©rique
      // ===== INTERFACES REPOSITORY =====
      class IRepository {
        async save(entity) {
          throw new Error("Not implemented");
        }
        async findById(id, ownerId, driverId) {
          throw new Error("Not implemented");
        }
        async findAll(filters = {}) {
          // filters peut inclure : { ownerId, driverId, date, status, etc. }
          throw new Error("Not implemented");
        }
        async update(id, updates, ownerId, driverId) {
          throw new Error("Not implemented");
        }
        async delete(id, ownerId, driverId) {
          throw new Error("Not implemented");
        }
        async count(filters = {}) {
          throw new Error("Not implemented");
        }
      }
      // ===== IMPL√âMENTATIONS LOCALSTORAGE =====

      // Repository Course
      // ===== REPOSITORY : TRIP (LOCALSTORAGE) =====
      class TripRepository extends IRepository {
        constructor() {
          super();
          this.storageKey = "taxitracker_trips";
          this.initStorage();
        }

        initStorage() {
          if (!localStorage.getItem(this.storageKey)) {
            localStorage.setItem(this.storageKey, JSON.stringify([]));
          }
        }

        async save(trip) {
          const trips = await this.findAll();
          const tripEntity =
            trip instanceof Trip ? trip : Trip._deserialize(trip);
          trips.push(tripEntity.toJSON());
          localStorage.setItem(this.storageKey, JSON.stringify(trips));
          return tripEntity;
        }

        async findById(id, ownerId, driverId) {
          const trips = await this.findAll({ ownerId, driverId });
          const data = trips.find((t) => t.id === id);
          return data ? Trip._deserialize(data) : null;
        }

        async findAll(filters = {}) {
          const trips = JSON.parse(
            localStorage.getItem(this.storageKey) || "[]"
          );
          return trips.filter((trip) => {
            if (filters.ownerId && trip.ownerId !== filters.ownerId)
              return false;
            if (filters.driverId && trip.driverId !== filters.driverId)
              return false;
            if (filters.date) {
              const tripDate = new Date(trip.startTime).toDateString();
              const filterDate = new Date(filters.date).toDateString();
              if (tripDate !== filterDate) return false;
            }
            if (filters.status && trip.status !== filters.status) return false;
            return true;
          });
        }

        async update(id, updates, ownerId, driverId) {
          const trips = await this.findAll({ ownerId, driverId });
          const index = trips.findIndex((t) => t.id === id);
          if (index === -1)
            throw new Error(`Trip ${id} not found for owner ${ownerId}`);
          trips[index] = {
            ...trips[index],
            ...updates,
            updatedAt: new Date().toISOString(),
          };
          localStorage.setItem(this.storageKey, JSON.stringify(trips));
          return Trip._deserialize(trips[index]);
        }

        async delete(id, ownerId, driverId) {
          const trips = await this.findAll({ ownerId, driverId });
          const filtered = trips.filter((t) => t.id !== id);
          localStorage.setItem(this.storageKey, JSON.stringify(filtered));
        }

        async count(filters = {}) {
          const trips = await this.findAll(filters);
          return trips.length;
        }
      }
      // Repository GPS
      // ===== REPOSITORY : GPS POINT (LOCALSTORAGE) =====
      class GPSPointRepository extends IRepository {
        constructor() {
          super();
          this.storageKey = "taxitracker_gps_points";
          this.maxPoints = 10000; // limite globale
          this.initStorage();
        }

        initStorage() {
          if (!localStorage.getItem(this.storageKey)) {
            localStorage.setItem(this.storageKey, JSON.stringify([]));
          }
        }

        async save(point) {
          const points = await this.findAll();
          const pointEntity =
            point instanceof GPSPoint ? point : GPSPoint._deserialize(point);
          points.push(pointEntity.toJSON());
          // Nettoyage si d√©passement
          if (points.length > this.maxPoints) {
            points.splice(0, points.length - this.maxPoints);
          }
          localStorage.setItem(this.storageKey, JSON.stringify(points));
          return pointEntity;
        }

        async findByTripId(tripId, ownerId, driverId) {
          return this.findAll({ tripId, ownerId, driverId });
        }

        async findAll(filters = {}) {
          const points = JSON.parse(
            localStorage.getItem(this.storageKey) || "[]"
          );
          return points.filter((point) => {
            if (filters.tripId && point.tripId !== filters.tripId) return false;
            if (filters.ownerId && point.ownerId !== filters.ownerId)
              return false;
            if (filters.driverId && point.driverId !== filters.driverId)
              return false;
            if (filters.date) {
              const pointDate = new Date(point.timestamp).toDateString();
              const filterDate = new Date(filters.date).toDateString();
              if (pointDate !== filterDate) return false;
            }
            return true;
          });
        }

        // Pas de update/delete pour les points GPS (immutable par design)
        async update() {
          throw new Error("GPSPoint is immutable");
        }
        async delete() {
          throw new Error("GPSPoint is immutable");
        }
      }
      // Repository Statistiques
      // ===== REPOSITORY : DAILY STATS (LOCALSTORAGE) =====
      class DailyStatsRepository extends IRepository {
        constructor() {
          super();
          this.storageKey = "taxitracker_daily_stats";
          this.initStorage();
        }

        initStorage() {
          if (!localStorage.getItem(this.storageKey)) {
            localStorage.setItem(this.storageKey, JSON.stringify([]));
          }
        }

        async save(stats) {
          const allStats = await this.findAll();
          const statsEntity =
            stats instanceof DailyStats
              ? stats
              : DailyStats._deserialize(stats);
          // Remplacer si existe d√©j√† pour (date + driverId)
          const existingIndex = allStats.findIndex(
            (s) =>
              s.date === statsEntity.date && s.driverId === statsEntity.driverId
          );
          if (existingIndex >= 0) {
            allStats[existingIndex] = statsEntity.toJSON();
          } else {
            allStats.push(statsEntity.toJSON());
          }
          localStorage.setItem(this.storageKey, JSON.stringify(allStats));
          return statsEntity;
        }

        async findByDate(date, ownerId, driverId) {
          const dateStr =
            typeof date === "string" ? date : date.toISOString().split("T")[0];
          const allStats = await this.findAll({ ownerId, driverId });
          const data = allStats.find((s) => s.date === dateStr);
          return data ? DailyStats._deserialize(data) : null;
        }

        async findAll(filters = {}) {
          const stats = JSON.parse(
            localStorage.getItem(this.storageKey) || "[]"
          );
          return stats.filter((stat) => {
            if (filters.ownerId && stat.ownerId !== filters.ownerId)
              return false;
            if (filters.driverId && stat.driverId !== filters.driverId)
              return false;
            if (filters.date) {
              const statDate = stat.date;
              const filterDate =
                typeof filters.date === "string"
                  ? filters.date
                  : filters.date.toISOString().split("T")[0];
              if (statDate !== filterDate) return false;
            }
            return true;
          });
        }

        async getOrCreateToday(ownerId, driverId) {
          const today = new Date().toISOString().split("T")[0];
          let stats = await this.findByDate(today, ownerId, driverId);
          if (!stats) {
            stats = new DailyStats({
              date: today,
              ownerId: ownerId,
              driverId: driverId,
            });
            await this.save(stats);
          }
          return stats;
        }

        // Pas de delete/update direct ‚Äî on remplace via save()
        async update() {
          throw new Error("Use save() instead");
        }
        async delete() {
          throw new Error("Stats are not deletable");
        }
      }

      // ===== REPOSITORY : WORK SCHEDULE =====
      class WorkScheduleRepository extends IRepository {
        constructor() {
          super();
          this.storageKey = "taxitracker_work_schedule";
          this.initStorage();
        }

        initStorage() {
          if (!localStorage.getItem(this.storageKey)) {
            localStorage.setItem(this.storageKey, JSON.stringify({}));
          }
        }

        async save(schedule) {
          const schedules = JSON.parse(
            localStorage.getItem(this.storageKey) || "{}"
          );
          const key = `${schedule.ownerId}_${schedule.driverId}`;
          schedules[key] = schedule.toJSON();
          localStorage.setItem(this.storageKey, JSON.stringify(schedules));
          return schedule;
        }

        async findByDriver(ownerId, driverId) {
          const schedules = JSON.parse(
            localStorage.getItem(this.storageKey) || "{}"
          );
          const key = `${ownerId}_${driverId}`;
          const data = schedules[key];
          return WorkSchedule.fromJSON(data);
        }

        // Pas de findAll, update, delete pour l‚Äôinstant
        async findAll() {
          throw new Error("Not implemented");
        }
        async update() {
          throw new Error("Not implemented");
        }
        async delete() {
          throw new Error("Not implemented");
        }
      }
      // ===== REPOSITORY : DAY LOG =====
      class DayLogRepository extends IRepository {
        constructor() {
          super();
          this.storageKey = "taxitracker_day_logs";
          this.initStorage();
        }

        initStorage() {
          if (!localStorage.getItem(this.storageKey)) {
            localStorage.setItem(this.storageKey, JSON.stringify([]));
          }
        }

        async save(log) {
          const logs = await this.findAll();
          const logEntity =
            log instanceof DayLogEntry ? log : DayLogEntry.fromJSON(log);
          logs.push(logEntity.toJSON());
          localStorage.setItem(this.storageKey, JSON.stringify(logs));
          return logEntity;
        }

        async findAll(filters = {}) {
          const logs = JSON.parse(
            localStorage.getItem(this.storageKey) || "[]"
          );
          return logs.filter((log) => {
            if (filters.ownerId && log.ownerId !== filters.ownerId)
              return false;
            if (filters.driverId && log.driverId !== filters.driverId)
              return false;
            if (filters.date) {
              const logDate = new Date(log.timestamp).toDateString();
              const filterDate = new Date(filters.date).toDateString();
              if (logDate !== filterDate) return false;
            }
            if (filters.type && log.type !== filters.type) return false;
            return true;
          });
        }

        // Pas de findById, update, delete pour l‚Äôinstant
        async findById() {
          throw new Error("Not implemented");
        }
        async update() {
          throw new Error("Not implemented");
        }
        async delete() {
          throw new Error("Not implemented");
        }
      }
      // ===== INSTANCES GLOBALES =====
      // ===== FACTORY : REPOSITORY FACTORY =====
      class RepositoryFactory {
        static createTripRepository(mode = "local") {
          switch (mode) {
            case "local":
              return new TripRepository();
            // case "firebase":
            //   return new FirebaseTripRepository(); // √Ä impl√©menter plus tard
            default:
              throw new Error(`Mode de repository non support√©: ${mode}`);
          }
        }

        static createGPSRepository(mode = "local") {
          switch (mode) {
            case "local":
              return new GPSPointRepository();
            // case "firebase":
            //   return new FirebaseGPSRepository();
            default:
              throw new Error(`Mode de repository non support√©: ${mode}`);
          }
        }

        static createStatsRepository(mode = "local") {
          switch (mode) {
            case "local":
              return new DailyStatsRepository();
            // case "firebase":
            //   return new FirebaseStatsRepository();
            default:
              throw new Error(`Mode de repository non support√©: ${mode}`);
          }
        }
        static createDayLogRepository(mode = "local") {
          switch (mode) {
            case "local":
              return new DayLogRepository();
            default:
              throw new Error(`Mode non support√©: ${mode}`);
          }
        }
        static createWorkScheduleRepository(mode = "local") {
          switch (mode) {
            case "local":
              return new WorkScheduleRepository();
            default:
              throw new Error(`Mode non support√©: ${mode}`);
          }
        }
      }

      // ===== MODE D'EX√âCUTION =====
      const APP_MODE = "local"; // ‚Üê √† modifier plus tard si besoin

      // ===== INSTANCES GLOBALES VIA FACTORY =====
      const tripRepository = RepositoryFactory.createTripRepository(APP_MODE);
      const gpsRepository = RepositoryFactory.createGPSRepository(APP_MODE);
      const statsRepository = RepositoryFactory.createStatsRepository(APP_MODE);
      const workScheduleRepository =
        RepositoryFactory.createWorkScheduleRepository(APP_MODE);
      const dayLogRepository =
        RepositoryFactory.createDayLogRepository(APP_MODE);
      // ===== SYST√àME DE ZONES G√âOGRAPHIQUES =====

      // D√©finition des zones autoris√©es
      const AUTHORIZED_ZONES = {
        "pointe-noire": {
          name: "Pointe-Noire",
          center: { lat: -4.7692, lng: 11.8636 },
          radius: 25000, // 25km de rayon
          districts: [
            { name: "Centre-ville", lat: -4.7692, lng: 11.8636, radius: 3000 },
            { name: "Ti√©-Ti√©", lat: -4.75, lng: 11.85, radius: 2000 },
            { name: "Loandjili", lat: -4.8, lng: 11.88, radius: 2500 },
            { name: "Mongo-Mpoukou", lat: -4.73, lng: 11.84, radius: 2000 },
            { name: "Ngoyo", lat: -4.78, lng: 11.9, radius: 1500 },
            { name: "Vindoulou", lat: -4.74, lng: 11.87, radius: 1800 },
            { name: "Mpita", lat: -4.76, lng: 11.85, radius: 1500 },
          ],
        },
      };

      // Villes voisines pour r√©f√©rence
      const NEARBY_CITIES = [
        { name: "Dolisie", lat: -4.1989, lng: 12.6664 },
        { name: "Brazzaville", lat: -4.2634, lng: 15.2429 },
        { name: "Cabinda", lat: -5.55, lng: 12.2 },
        { name: "Luanda", lat: -8.839, lng: 13.2894 },
        { name: "Soyo", lat: -6.1364, lng: 12.3681 },
        { name: "Nzeto", lat: -7.2317, lng: 12.8644 },
      ];

      // √âtat de la zone actuelle
      let currentZoneStatus = {
        city: "Localisation...",
        district: null,
        authorized: false,
        distance: 0,
        lastUpdate: null,
      };

      // D√©tecter la zone actuelle
      function detectCurrentZone(lat, lng) {
        console.log(
          `üåç D√©tection zone pour: ${lat.toFixed(6)}, ${lng.toFixed(6)}`
        );

        // V√©rifier Pointe-Noire
        const pnZone = AUTHORIZED_ZONES["pointe-noire"];
        const distanceToPN = calculateDistance(
          lat,
          lng,
          pnZone.center.lat,
          pnZone.center.lng
        );

        if (distanceToPN <= pnZone.radius) {
          // Dans Pointe-Noire - d√©tecter le quartier
          let closestDistrict = null;
          let minDistance = Infinity;

          pnZone.districts.forEach((district) => {
            const distanceToDistrict = calculateDistance(
              lat,
              lng,
              district.lat,
              district.lng
            );
            if (
              distanceToDistrict <= district.radius &&
              distanceToDistrict < minDistance
            ) {
              minDistance = distanceToDistrict;
              closestDistrict = district.name;
            }
          });
          currentZoneStatus = {
            city: "Pointe-Noire",
            district: closestDistrict || "Zone p√©riph√©rique",
            authorized: true,
            distance: Math.round((distanceToPN / 1000) * 10) / 10,
            lastUpdate: Date.now(),
          };

          console.log("‚úÖ Zone autoris√©e:", currentZoneStatus);
          return currentZoneStatus;
        }

        // V√©rifier villes voisines
        let closestCity = null;
        let minCityDistance = Infinity;

        NEARBY_CITIES.forEach((city) => {
          const distance = calculateDistance(lat, lng, city.lat, city.lng);
          if (distance < minCityDistance) {
            minCityDistance = distance;
            closestCity = city.name;
          }
        });
        // Si proche d'une ville connue (< 50km)
        if (minCityDistance < 50000) {
          currentZoneStatus = {
            city: closestCity,
            district: null,
            authorized: false,
            distance: Math.round((distanceToPN / 1000) * 10) / 10,
            lastUpdate: Date.now(),
          };
        } else {
          // Zone inconnue
          currentZoneStatus = {
            city: "Zone inconnue",
            district: null,
            authorized: false,
            distance: Math.round((distanceToPN / 1000) * 10) / 10,
            lastUpdate: Date.now(),
          };
        }

        console.log("‚ùå Zone non autoris√©e:", currentZoneStatus);
        return currentZoneStatus;
      }

      // Mettre √† jour l'affichage de la zone
      function updateZoneDisplay() {
        console.log("üñ•Ô∏è Mise √† jour affichage zone...");

        // Trouver le conteneur de zone par son contenu
        const allContainers = document.querySelectorAll(
          ".bg-gray-800.rounded-xl.p-4.shadow-lg"
        );
        let zoneContainer = null;

        allContainers.forEach((container) => {
          const text = container.textContent;
          if (
            text.includes("Zone") ||
            text.includes("üìç") ||
            text.includes("Pointe-Noire")
          ) {
            zoneContainer = container;
          }
        });
        if (!zoneContainer) {
          console.warn("‚ö†Ô∏è Conteneur de zone non trouv√©");
          return;
        }
        // Reconstruire le contenu de la zone
        if (currentZoneStatus.authorized) {
          // Zone autoris√©e - vert
          zoneContainer.innerHTML = `
            <div class="flex items-center justify-between">
              <div class="flex items-center space-x-3">
                <span class="text-2xl">üìç</span>
                <div>
                  <p class="font-medium">${currentZoneStatus.city}</p>
                  <p class="text-sm text-green-400">
                    ${
                      currentZoneStatus.district
                        ? currentZoneStatus.district + " ‚Ä¢ "
                        : ""
                    }Zone autoris√©e
                  </p>
                </div>
              </div>
              <div class="w-3 h-3 bg-green-400 rounded-full"></div>
            </div>
          `;
        } else {
          // Zone non autoris√©e - rouge
          zoneContainer.innerHTML = `
            <div class="flex items-center justify-between">
              <div class="flex items-center space-x-3">
                <span class="text-2xl">‚ö†Ô∏è</span>
                <div>
                  <p class="font-medium">${currentZoneStatus.city}</p>
                  <p class="text-sm text-red-400">
                    Zone non autoris√©e ‚Ä¢ ${currentZoneStatus.distance}km de Pointe-Noire
                  </p>
                </div>
              </div>
              <div class="w-3 h-3 bg-red-400 rounded-full"></div>
            </div>
          `;

          // Alerte si en service dans une zone non autoris√©e
          if (
            appState.dayStarted &&
            !appState.paused &&
            !appState.currentTrip
          ) {
            addFraudAlert(`Service actif hors zone: ${currentZoneStatus.city}`);
          }
        }
        console.log("‚úÖ Affichage zone mis √† jour:", currentZoneStatus.city);
      }
      // V√©rification p√©riodique de la zone
      function startZoneMonitoring() {
        console.log("üîÑ D√©marrage monitoring des zones...");

        setInterval(() => {
          if (appState.currentPosition && appState.dayStarted) {
            const previousCity = currentZoneStatus.city;
            const previousAuthorized = currentZoneStatus.authorized;

            detectCurrentZone(
              appState.currentPosition.lat,
              appState.currentPosition.lng
            );

            // Mettre √† jour si changement significatif
            if (
              currentZoneStatus.city !== previousCity ||
              currentZoneStatus.authorized !== previousAuthorized
            ) {
              updateZoneDisplay();

              // Log du changement de zone
              if (
                previousCity !== "Localisation..." &&
                currentZoneStatus.city !== previousCity
              ) {
                console.log(
                  `üöó Changement de zone: ${previousCity} ‚Üí ${currentZoneStatus.city}`
                );
              }
            }
          }
        }, 15000); // V√©rifier toutes les 15 secondes
      }

      // Initialiser l'affichage de zone au d√©marrage
      function initializeZoneDisplay() {
        console.log("üèÅ Initialisation affichage zone...");

        // Affichage initial
        currentZoneStatus = {
          city: "Localisation...",
          district: null,
          authorized: false,
          distance: 0,
          lastUpdate: null,
        };

        updateZoneDisplay();
      }
      // ===== GPS TRACKING SYSTEM SIMPLIFI√â =====

      // Configuration GPS
      const GPS_CONFIG = {
        highAccuracy: true,
        timeout: 15000,
        maximumAge: 5000,
      };

      // Zones tarifaires Pointe-Noire
      const PRICING_ZONES = {
        "centre-ville": { base: 500, perKm: 400, perMin: 25 },
        banlieue: { base: 300, perKm: 250, perMin: 15 },
        aeroport: { base: 1000, perKm: 500, perMin: 30 },
        port: { base: 800, perKm: 350, perMin: 20 },
        "hors-zone": { base: 1500, perKm: 800, perMin: 50 }, // NOUVEAU - Tarif major√©
        default: { base: 400, perKm: 300, perMin: 20 },
      };

      // App State avec GPS
      let appState = {
        dayStarted: false,
        paused: false,
        pauseStartTime: null,
        currentTrip: null,
        tripStartTime: null,
        dailyEarnings: 12500,
        tripCount: 8,
        cameraStream: null,
        periodicTimerId: null,
        currentSchedule: null,
        scheduleDeviations: [],
        lastActivityTime: null,
        // GPS Tracking State
        gpsWatchId: null,
        currentPosition: null,
        positionBuffer: [],
        tripPoints: [],
        lastValidPosition: null,
        trackingActive: false,
        totalDistance: 0,
        isOnline: navigator.onLine,
        // Fraud Detection
        suspiciousEvents: [],
        lastSpeedCheck: null,
        trustScore: 100,
        // Identifiants utilisateur
        currentDriverId: "drv_mbemba_jean", // ‚Üê √† remplacer dynamiquement
        currentOwnerId: "own_taxi_123",
      };

      // ===== UTILITAIRES GPS =====
      // Calcul distance Haversine (en m√®tres)
      function calculateDistance(lat1, lng1, lat2, lng2) {
        const R = 6371000; // Rayon terre en m√®tres
        const dLat = ((lat2 - lat1) * Math.PI) / 180;
        const dLng = ((lng2 - lng1) * Math.PI) / 180;
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos((lat1 * Math.PI) / 180) *
            Math.cos((lat2 * Math.PI) / 180) *
            Math.sin(dLng / 2) *
            Math.sin(dLng / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }
      // ===== UTILITAIRE : POSITION AVEC SECOURS =====
      function getValidPositionWithFallback() {
        const now = Date.now();
        const current = appState.currentPosition;
        const lastValid = appState.lastValidPosition;

        // Cas 1 : position actuelle valide (< 1000m)
        if (current && current.accuracy <= 1000) {
          return {
            position: { ...current },
            source: "current",
            isApproximate: false,
          };
        }

        // Cas 2 : derni√®re position valide < 30s et pr√©cise
        if (
          lastValid &&
          now - lastValid.timestamp < 30000 &&
          lastValid.accuracy <= 1000
        ) {
          return {
            position: { ...lastValid },
            source: "recent",
            isApproximate: true,
          };
        }

        // Cas 3 : fallback Pointe-Noire
        return {
          position: {
            lat: -4.7692,
            lng: 11.8636,
            accuracy: 500,
            timestamp: now,
          },
          source: "fallback",
          isApproximate: true,
        };
      }

      // ===== JOURNALISATION DES ACTIONS =====
      async function logDriverAction(type, metadata = {}) {
        const log = new DayLogEntry({
          type: type,
          metadata: metadata,
        });
        await dayLogRepository.save(log);
        console.log(`üìù Journal : ${type}`, log);
      }
      // ===== SYST√àME DE CARTE GPS =====

      // ===== SYST√àME DE TRACKING SIMPLIFI√â =====

      // D√©marrer tracking GPS
      function startGPSTracking() {
        console.log("üîÑ D√©marrage GPS tracking...");

        if (!navigator.geolocation) {
          console.error("‚ùå GPS non support√©");
          updateGPSStatus("Non support√©", "text-red-400");
          return false;
        }

        updateGPSStatus("D√©marrage...", "text-yellow-400");

        const options = {
          enableHighAccuracy: true,
          timeout: 15000,
          maximumAge: 5000,
        };

        console.log("üì° Lancement watchPosition...");

        appState.gpsWatchId = navigator.geolocation.watchPosition(
          (position) => {
            console.log("üéØ GPS SUCCESS:", {
              lat: position.coords.latitude.toFixed(6),
              lng: position.coords.longitude.toFixed(6),
              accuracy: Math.round(position.coords.accuracy),
              time: new Date().toLocaleTimeString(),
            });
            handleGPSSuccess(position);
          },
          (error) => {
            console.error("‚ùå GPS ERROR:", error.message);
            handleGPSError(error);
          },
          options
        );

        appState.trackingActive = true;
        console.log("‚úÖ WatchPosition lanc√©, ID:", appState.gpsWatchId);

        // Test timeout
        // Ne pas marquer comme "d√©sactiv√©" en offline ‚Äî le GPS peut √™tre lent
        // Garder le statut "D√©marrage..." pendant 30s max
        setTimeout(() => {
          if (appState.positionBuffer.length === 0 && appState.trackingActive) {
            updateGPSStatus("Recherche satellite...", "text-yellow-400");
            // Continuer √† √©couter ‚Äî ne pas arr√™ter
          }
        }, 30000); // 30 secondes, pas 5

        return true;
      }

      // Arr√™ter tracking GPS
      function stopGPSTracking() {
        console.log("üõë Arr√™t GPS tracking...");
        if (appState.gpsWatchId) {
          navigator.geolocation.clearWatch(appState.gpsWatchId);
          appState.gpsWatchId = null;
        }

        appState.trackingActive = false;
        updateGPSStatus("D√©sactiv√©", "text-red-400");
        document.getElementById("gps-indicator").className =
          "w-3 h-3 bg-red-400 rounded-full";
      }

      // Succ√®s GPS
      function handleGPSSuccess(position) {
        // Mettre √† jour le statut imm√©diatement
        updateGPSStatus("Actif", "text-green-400");
        document.getElementById("gps-indicator").className =
          "gps-indicator w-3 h-3 bg-green-400 rounded-full";

        // Validation basique
        if (!position || !position.coords) {
          console.warn("‚ùå Position invalide");
          return;
        }

        const { latitude, longitude, accuracy } = position.coords;

        // V√©rifications de base
        if (Math.abs(latitude) > 90 || Math.abs(longitude) > 180) {
          console.warn("‚ùå Coordonn√©es invalides");
          return;
        }

        // Rejeter positions trop impr√©cises
        if (accuracy == null || accuracy > 1000) {
          console.warn("‚ùå Position GPS rejet√©e : pr√©cision > 1000m");
          return;
        }

        // Cr√©er le point GPS
        const point = {
          lat: latitude,
          lng: longitude,
          ts: Date.now(),
          accuracy: accuracy || 0,
          speed: position.coords.speed || 0,
          heading: position.coords.heading || 0,
          provider: "html5",
        };

        point.timestamp = Date.now();

        appState.currentPosition = point;
        appState.lastValidPosition = point;

        // Calcul de vitesse manuel (offline-safe)
        if (appState.lastValidPosition) {
          const distanceM = calculateDistance(
            appState.lastValidPosition.lat,
            appState.lastValidPosition.lng,
            point.lat,
            point.lng
          );
          const timeDiffMs = point.ts - appState.lastValidPosition.ts;
          if (timeDiffMs > 0) {
            const speedMps = distanceM / (timeDiffMs / 1000); // m/s
            point.speed = speedMps; // remplace position.coords.speed
          }
        }

        // Ajouter au buffer
        appState.positionBuffer.push(point);

        // Limiter taille buffer
        if (appState.positionBuffer.length > 1000) {
          appState.positionBuffer.shift();
        }

        // Si en course, ajouter aux points du trip
        if (appState.currentTrip) {
          appState.tripPoints.push(point);
          updateTripDistance();
          console.log(
            "üöó Point ajout√© √† la course, total:",
            appState.tripPoints.length
          );
        }

        // Mettre √† jour UI
        updateGPSDisplay(point);

        // D√©tecter et mettre √† jour la zone g√©ographique
        detectCurrentZone(point.lat, point.lng);
        updateZoneDisplay();

        console.log(
          "‚úÖ Point GPS trait√© - Buffer:",
          appState.positionBuffer.length,
          "points"
        );
      }

      // Erreur GPS
      function handleGPSError(error) {
        console.error("‚ùå Erreur GPS:", error);
        let message = "Erreur GPS inconnue";

        switch (error.code) {
          case error.PERMISSION_DENIED:
            message = "Permission GPS refus√©e";
            break;
          case error.POSITION_UNAVAILABLE:
            message = "Position indisponible";
            break;
          case error.TIMEOUT:
            message = "Timeout GPS";
            break;
        }

        // En offline, ce n‚Äôest pas une erreur fatale
        if (
          error.code === error.TIMEOUT ||
          error.code === error.POSITION_UNAVAILABLE
        ) {
          updateGPSStatus("Signal faible", "text-yellow-400");
          // Ne PAS arr√™ter le tracking ‚Äî continue d‚Äô√©couter
        } else {
          updateGPSStatus(message, "text-red-400");
        }
        document.getElementById("gps-indicator").className =
          "w-3 h-3 bg-red-400 rounded-full";
      }

      // ===== CALCULS DE DISTANCE ET PRIX =====

      // Calculer distance totale du trip
      function calculateTripDistance() {
        if (appState.tripPoints.length < 2) return 0;

        let totalDistance = 0;
        for (let i = 1; i < appState.tripPoints.length; i++) {
          const prev = appState.tripPoints[i - 1];
          const curr = appState.tripPoints[i];
          totalDistance += calculateDistance(
            prev.lat,
            prev.lng,
            curr.lat,
            curr.lng
          );
        }

        return totalDistance / 1000; // en kilom√®tres
      }

      // Estimer prix d'une course
      function estimatePrice(distanceKm, durationMin, zone = "default") {
        const pricing = PRICING_ZONES[zone] || PRICING_ZONES.default;

        const basePrice = pricing.base;
        const distancePrice = distanceKm * pricing.perKm;
        const timePrice = durationMin * pricing.perMin;

        return Math.round(basePrice + distancePrice + timePrice);
      }

      // D√©tecter zone tarifaire (simulation basique)
      function detectPricingZone(lat, lng) {
        // Utiliser la d√©tection de zone existante
        const zoneInfo = detectCurrentZone(lat, lng);

        if (!zoneInfo.authorized) {
          return "hors-zone"; // Tarif major√© hors zone
        }

        // Tarifs selon le quartier √† Pointe-Noire
        switch (zoneInfo.district) {
          case "Centre-ville":
            return "centre-ville";
          case "Ti√©-Ti√©":
            return "banlieue";
          case "Loandjili":
            return "port";
          case "Ngoyo":
            return "aeroport";
          default:
            return "default";
        }
      }

      // ===== D√âTECTION DE FRAUDE =====

      // Ajouter alerte fraude
      function addFraudAlert(message) {
        appState.suspiciousEvents.push({
          message,
          timestamp: Date.now(),
          position: appState.currentPosition,
        });

        // R√©duire score de confiance
        appState.trustScore = Math.max(0, appState.trustScore - 0.001);
        updateTrustScore();

        console.warn("üö® FRAUDE D√âTECT√âE:", message);
      }

      // ===== JOURNAL DES √âCARTS DE PLANNING =====
      function logScheduleDeviation(type, details) {
        const deviation = {
          type: type, // 'early_start', 'late_end', 'inactive_during_hours', 'worked_outside_hours'
          details: details,
          timestamp: Date.now(),
        };
        appState.scheduleDeviations = appState.scheduleDeviations || [];
        appState.scheduleDeviations.push(deviation);
        console.log("üìù √âcart planning :", type, details);
      }
      // ===== INTERFACE UTILISATEUR =====

      // Mettre √† jour affichage GPS
      function updateGPSDisplay(point) {
        console.log("üñ•Ô∏è Mise √† jour UI GPS");
        document.getElementById("gps-accuracy").textContent = `${Math.round(
          point.accuracy || 0
        )}m`;
        document.getElementById("gps-speed").textContent = `${Math.round(
          (point.speed || 0) * 3.6
        )} km/h`;
        document.getElementById("points-count").textContent =
          appState.positionBuffer.length;
        document.getElementById(
          "last-position"
        ).textContent = `${point.lat.toFixed(4)}, ${point.lng.toFixed(4)}`;
      }

      // Mettre √† jour statut GPS
      function updateGPSStatus(status, colorClass) {
        const statusEl = document.getElementById("gps-status");
        statusEl.textContent = status;
        statusEl.className = `${colorClass} text-sm`;
        console.log("üìä Statut GPS:", status);
      }

      // Mettre √† jour distance du trip
      function updateTripDistance() {
        const distance = calculateTripDistance();
        document.getElementById(
          "current-distance"
        ).textContent = `${distance.toFixed(2)} km`;

        // Mettre √† jour prix estim√©
        const duration = (Date.now() - appState.tripStartTime) / 60000;
        const zone = appState.currentPosition
          ? detectPricingZone(
              appState.currentPosition.lat,
              appState.currentPosition.lng
            )
          : "default";
        const estimatedPrice = estimatePrice(distance, duration, zone);

        document.getElementById(
          "estimated-current-price"
        ).textContent = `${estimatedPrice} FCFA`;

        // V√©rifier √©cart prix
        const declaredPrice = appState.currentTrip.amount;
        const priceDiff =
          Math.abs(declaredPrice - estimatedPrice) / estimatedPrice;

        if (priceDiff > 0.3) {
          // 30% d'√©cart
          addFraudAlert(
            `√âcart prix suspect: ${declaredPrice} vs ${estimatedPrice} FCFA estim√©`
          );
        }
      }

      // Mettre √† jour score de confiance
      function updateTrustScore() {
        document.getElementById(
          "trust-score"
        ).textContent = `${appState.trustScore}%`;
        document.getElementById(
          "trust-bar"
        ).style.width = `${appState.trustScore}%`;

        const scoreEl = document.getElementById("trust-score");
        const barEl = document.getElementById("trust-bar");

        if (appState.trustScore >= 80) {
          scoreEl.className = "text-green-400 font-bold";
          barEl.className = "bg-green-400 h-2 rounded-full";
        } else if (appState.trustScore >= 60) {
          scoreEl.className = "text-yellow-400 font-bold";
          barEl.className = "bg-yellow-400 h-2 rounded-full";
        } else {
          scoreEl.className = "text-red-400 font-bold";
          barEl.className = "bg-red-400 h-2 rounded-full";
        }
      }

      // ===== INT√âGRATION AVEC L'APP EXISTANTE =====

      // DOM Elements
      const startDayBtn = document.getElementById("start-day-btn");
      const declareTripBtn = document.getElementById("declare-trip-btn");
      const pauseBtn = document.getElementById("pause-btn");
      const statusBadge = document.getElementById("status-badge");
      const tripModal = document.getElementById("trip-modal");
      const cameraModal = document.getElementById("camera-modal");
      const resultModal = document.getElementById("result-modal");
      const currentTripCard = document.getElementById("current-trip");

      // Camera permission check
      async function checkCameraPermission() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: true,
          });
          stream.getTracks().forEach((track) => track.stop());
          return true;
        } catch (err) {
          alert("‚ö†Ô∏è Cam√©ra non autoris√©e. Contactez votre propri√©taire.");
          return false;
        }
      }

      // Helpers to enable/disable buttons nicely
      function setButtonState(el, enabled) {
        el.disabled = !enabled;
        if (enabled) {
          el.classList.remove("opacity-50", "cursor-not-allowed");
        } else {
          if (!el.classList.contains("opacity-50"))
            el.classList.add("opacity-50");
          if (!el.classList.contains("cursor-not-allowed"))
            el.classList.add("cursor-not-allowed");
        }
      }

      function updateStatusBadge(text, colorClasses) {
        statusBadge.textContent = text;
        statusBadge.className =
          "px-3 py-1 rounded-full text-sm font-medium " + colorClasses;
      }

      // Start/End day toggle avec GPS
      startDayBtn.addEventListener("click", async () => {
        if (!appState.dayStarted) {
          const hasCamera = await checkCameraPermission();
          if (!hasCamera) return;

          // D√©marrer GPS
          if (!startGPSTracking()) {
            alert("‚ö†Ô∏è Impossible de d√©marrer le GPS. Fonctionnalit√© requise.");
            return;
          }

          appState.dayStarted = true;
          await logDriverAction("start_day", {
            gpsPosition: appState.currentPosition,
            timestamp: Date.now(),
          });
          // V√©rifier respect du planning au d√©marrage
          if (appState.currentSchedule?.active) {
            const now = new Date();
            if (!isWithinWorkHours(now, appState.currentSchedule)) {
              const expectedStart = appState.currentSchedule.workStartHour;
              logScheduleDeviation("early_start", {
                actualTime: now.toLocaleTimeString(),
                plannedStart: `${appState.currentSchedule.workStartHour}h`,
                tolerance: appState.currentSchedule.toleranceMinutes,
              });
            }
          }
          appState.paused = false;
          startDayBtn.textContent = "‚èπÔ∏è Terminer la journ√©e";
          startDayBtn.className =
            "w-full bg-red-600 hover:bg-red-700 text-white font-semibold py-4 px-6 rounded-xl transition-colors shadow-lg";

          setButtonState(declareTripBtn, true);
          setButtonState(pauseBtn, true);
          updateStatusBadge("En service", "bg-green-500 text-white");

          startPeriodicVerification();
        } else {
          // End day
          endDay();
        }
      });

      async function endDay() {
        // Stop any current trip
        if (appState.currentTrip) {
          if (
            !confirm(
              "Une course est en cours. Voulez-vous vraiment terminer la journ√©e ?"
            )
          ) {
            return;
          }
          // Soft-reset current trip UI/state
          appState.currentTrip = null;
          appState.tripStartTime = null;
          appState.tripPoints = [];
          currentTripCard.classList.add("hidden");
        }

        // Arr√™ter GPS
        stopGPSTracking();

        // V√©rifier respect du planning √† la fin
        if (appState.currentSchedule?.active) {
          const now = new Date();
          if (!isWithinWorkHours(now, appState.currentSchedule)) {
            const expectedEnd = appState.currentSchedule.workEndHour;
            logScheduleDeviation("late_end", {
              actualTime: now.toLocaleTimeString(),
              plannedEnd: `${appState.currentSchedule.workEndHour}h`,
              tolerance: appState.currentSchedule.toleranceMinutes,
            });
          }
        }

        appState.dayStarted = false;
        await logDriverAction("end_day", {
          totalTrips: appState.tripCount,
          totalEarnings: appState.dailyEarnings,
          timestamp: Date.now(),
        });
        appState.paused = false;
        startDayBtn.textContent = "‚ñ∂Ô∏è D√©marrer la journ√©e";
        startDayBtn.className =
          "w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-4 px-6 rounded-xl transition-colors shadow-lg";

        setButtonState(declareTripBtn, false);
        setButtonState(pauseBtn, false);
        updateStatusBadge("Libre", "bg-yellow-500 text-black");

        stopPeriodicVerification();

        // Stop camera if left on
        try {
          if (appState.cameraStream) {
            appState.cameraStream.getTracks().forEach((t) => t.stop());
            appState.cameraStream = null;
          }
        } catch {}
      }

      // Pause/Resume toggle
      pauseBtn.addEventListener("click", async () => {
        if (!appState.dayStarted) return;

        appState.paused = !appState.paused;

        if (appState.paused) {
          await logDriverAction("pause_end", {
            pauseDuration: Date.now() - (appState.pauseStartTime || Date.now()),
            timestamp: Date.now(),
          });
          pauseBtn.textContent = "‚ñ∂Ô∏è Reprendre";
          updateStatusBadge("En pause", "bg-orange-500 text-white");
          setButtonState(declareTripBtn, false);
          stopPeriodicVerification();
        } else {
          pauseBtn.textContent = "‚è∏Ô∏è Pause";
          appState.pauseStartTime = Date.now();
          await logDriverAction("pause_start", {
            timestamp: appState.pauseStartTime,
          });
          updateStatusBadge("En service", "bg-green-500 text-white");
          setButtonState(declareTripBtn, true);
          startPeriodicVerification();
        }
      });

      // Declare trip avec estimation prix
      declareTripBtn.addEventListener("click", () => {
        if (!appState.dayStarted || appState.paused) return;

        tripModal.classList.remove("hidden");
        tripModal.classList.add("flex");
        // Reset inputs
        document.getElementById("trip-amount").value = "";
        document.getElementById("passenger-count").value = "1";
      });

      // Cancel trip declaration
      document.getElementById("cancel-trip").addEventListener("click", () => {
        tripModal.classList.add("hidden");
        tripModal.classList.remove("flex");
      });

      // Start trip with verification
      document
        .getElementById("start-trip")
        .addEventListener("click", async () => {
          const amount = document.getElementById("trip-amount").value;
          const passengers = document.getElementById("passenger-count").value;

          if (!amount) {
            alert("Veuillez saisir le montant");
            return;
          }

          setButtonState(declareTripBtn, false);
          setButtonState(pauseBtn, false);
          setButtonState(startDayBtn, false);

          const startPosInfo = getValidPositionWithFallback();

          appState.currentTrip = {
            amount: parseInt(amount),
            passengers: parseInt(passengers),
            startPosition: startPosInfo.position,
            startTime: Date.now(),
          };

          // R√©initialiser points du trip
          appState.tripPoints = [];
          if (startPosInfo.position) {
            appState.tripPoints.push(startPosInfo.position);
          }

          tripModal.classList.add("hidden");
          tripModal.classList.remove("flex");

          startTrip();

          // Start camera verification
          // await startCameraVerification();
        });

      // Camera verification
      async function startCameraVerification() {
        cameraModal.classList.remove("hidden");
        cameraModal.classList.add("flex");

        // Reset overlay/message each time
        document.getElementById("verification-message").textContent =
          "V√©rification dans ";
        // document.getElementById("countdown").textContent = "5";
        const overlay = document.getElementById("skeleton-overlay");
        overlay.classList.add("hidden");

        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: true,
          });
          const video = document.getElementById("camera-feed");
          video.srcObject = stream;
          appState.cameraStream = stream;

          // Countdown
          let countdown = 5;
          const countdownEl = document.getElementById("countdown");
          const interval = setInterval(() => {
            countdown--;
            countdownEl.textContent = String(countdown);
            if (countdown <= 0) {
              clearInterval(interval);
              captureAndAnalyze();
            }
          }, 1000);
        } catch (err) {
          alert("Erreur cam√©ra: " + err.message);
          cameraModal.classList.add("hidden");
          cameraModal.classList.remove("flex");
        }
      }

      // Capture and analyze
      async function captureAndAnalyze() {
        document.getElementById("verification-message").textContent =
          "Analyse en cours...";
        const overlay = document.getElementById("skeleton-overlay");
        overlay.classList.remove("hidden");

        // Simulate AI analysis
        setTimeout(() => {
          const declaredPassengers = appState.currentTrip.passengers;
          const detectedPassengers =
            Math.random() > 0.3 ? declaredPassengers : declaredPassengers + 2; // 70% chance correct

          // Stop camera
          try {
            if (appState.cameraStream) {
              appState.cameraStream
                .getTracks()
                .forEach((track) => track.stop());
              appState.cameraStream = null;
            }
          } catch {}

          cameraModal.classList.add("hidden");
          cameraModal.classList.remove("flex");
          overlay.classList.add("hidden");
          showVerificationResult(declaredPassengers, detectedPassengers);
        }, 2000);
      }

      // Show verification result
      function showVerificationResult(declared, detected) {
        const resultIcon = document.getElementById("result-icon");
        const resultTitle = document.getElementById("result-title");
        const resultMessage = document.getElementById("result-message");

        if (Math.abs(declared - detected) <= 1) {
          // Success
          resultIcon.textContent = "‚úÖ";
          resultTitle.textContent = "V√©rification r√©ussie";
          resultMessage.textContent = `${detected} passager(s) d√©tect√©(s) - Conforme √† la d√©claration`;

          // Start trip
          startTrip();
        } else {
          // Alert
          resultIcon.textContent = "‚ö†Ô∏è";
          resultTitle.textContent = "√âcart d√©tect√©";
          resultMessage.textContent = `${detected} passager(s) d√©tect√©(s) vs ${declared} d√©clar√©(s) - Alerte envoy√©e au propri√©taire`;

          // Add fraud alert
          addFraudAlert(
            `√âcart passagers: ${detected} d√©tect√©s vs ${declared} d√©clar√©s`
          );

          // Cancel currentTrip if verification failed
          appState.currentTrip = null;
          appState.tripPoints = [];
        }

        resultModal.classList.remove("hidden");
        resultModal.classList.add("flex");
      }

      // Close result modal
      document.getElementById("close-result").addEventListener("click", () => {
        resultModal.classList.add("hidden");
        resultModal.classList.remove("flex");
      });

      // Start trip avec sauvegarde
      async function startTrip() {
        appState.tripStartTime = Date.now();

        await logDriverAction("trip_start", {
          tripId: appState.currentTrip.id,
          amount: appState.currentTrip.amount,
          passengers: appState.currentTrip.passengers,
          startPosition: appState.currentPosition,
          timestamp: appState.tripStartTime,
        });

        try {
          const savedTrip = await tripRepository.save({
            amount: appState.currentTrip.amount,
            passengers: appState.currentTrip.passengers,
            startPosition: appState.currentPosition,
            startTime: appState.tripStartTime,
            status: "active",
            driverId: appState.currentDriverId,
            ownerId: appState.currentOwnerId,
          });
          appState.currentTrip.id = savedTrip.id;
          console.log("üíæ Course sauvegard√©e:", savedTrip.id);
        } catch (error) {
          console.error("‚ùå Erreur sauvegarde:", error);
        }

        // Update UI (reste identique)
        document.getElementById("current-amount").textContent =
          appState.currentTrip.amount.toLocaleString() + " FCFA";
        document.getElementById("current-distance").textContent = "0.0 km";
        document.getElementById("estimated-current-price").textContent = "-";

        currentTripCard.classList.remove("hidden");
        updateStatusBadge("En course", "bg-blue-500 text-white");
        startTripTimer();
        appState.lastActivityTime = Date.now();
        // stopPeriodicVerification();
      }
      // Trip timer
      function startTripTimer() {
        const timer = setInterval(() => {
          if (!appState.tripStartTime) {
            clearInterval(timer);
            return;
          }
          const elapsed = Date.now() - appState.tripStartTime;
          const minutes = Math.floor(elapsed / 60000);
          const seconds = Math.floor((elapsed % 60000) / 1000);
          document.getElementById("trip-duration").textContent = `${minutes
            .toString()
            .padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
        }, 1000);
      }

      // End trip avec sauvegarde automatique
      document
        .getElementById("end-trip-btn")
        .addEventListener("click", async () => {
          if (!appState.currentTrip) return;

          // Analyse finale de la course
          const finalDistance = calculateTripDistance();
          const finalDuration = (Date.now() - appState.tripStartTime) / 60000;

          await logDriverAction("trip_end", {
            tripId: appState.currentTrip.id,
            distance: finalDistance.toFixed(2),
            duration: finalDuration,
            endPosition: appState.currentPosition,
            timestamp: Date.now(),
          });

          const zone = appState.currentPosition
            ? detectPricingZone(
                appState.currentPosition.lat,
                appState.currentPosition.lng
              )
            : "default";
          const finalEstimatedPrice = 0;
          try {
            // Inclure tous les points GPS de la course
            const tripPointsForStorage = appState.tripPoints.map((p) => ({
              lat: p.lat,
              lng: p.lng,
              accuracy: p.accuracy,
              timestamp: p.ts || p.timestamp,
            }));
            // Mettre √† jour la course dans la base
            const endPosInfo = getValidPositionWithFallback();
            await tripRepository.update(
              appState.currentTrip.id,
              {
                endPosition: appState.currentPosition,
                endTime: Date.now(),
                distance: finalDistance.toFixed(2),
                duration: finalDuration * 60000,
                zone: zone,
                estimatedPrice: finalEstimatedPrice,
                status: "completed",
                gpsPoints: tripPointsForStorage,
              },
              appState.currentOwnerId,
              appState.currentDriverId
            );
            // Sauvegarder tous les points GPS de la course
            for (const pt of appState.tripPoints) {
              await gpsRepository.save({
                lat: pt.lat,
                lng: pt.lng,
                accuracy: pt.accuracy,
                speed: pt.speed,
                heading: pt.heading,
                tripId: appState.currentTrip.id,
                driverId: appState.currentDriverId,
                ownerId: appState.currentOwnerId,
                timestamp: pt.ts || pt.timestamp,
              });
            }
            // Mettre √† jour les statistiques quotidiennes
            const todayStats = await statsRepository.getOrCreateToday(
              appState.currentOwnerId,
              appState.currentDriverId
            );
            todayStats.updateFromTrip({
              amount: appState.currentTrip.amount,
              distance: finalDistance.toFixed(2),
              duration: finalDuration * 60000,
              zone: zone,
              fraudAlerts: appState.suspiciousEvents.filter(
                (e) => e.timestamp > appState.tripStartTime
              ),
            });
            await statsRepository.save(todayStats);

            appState.lastActivityTime = Date.now();
            console.log("üíæ Course termin√©e et sauvegard√©e");
          } catch (error) {
            console.error("‚ùå Erreur sauvegarde fin de course:", error);
          }
          // Update earnings (interface seulement)
          appState.dailyEarnings += appState.currentTrip.amount;
          appState.tripCount++;

          document.getElementById("daily-earnings").textContent =
            appState.dailyEarnings.toLocaleString();
          document.getElementById("trip-count").textContent =
            appState.tripCount;

          // Reset trip
          appState.currentTrip = null;
          appState.tripStartTime = null;
          appState.tripPoints = [];

          currentTripCard.classList.add("hidden");
          updateStatusBadge(
            appState.dayStarted ? "En service" : "Libre",
            appState.dayStarted
              ? "bg-green-500 text-white"
              : "bg-yellow-500 text-black"
          );

          setButtonState(declareTripBtn, true);
          setButtonState(pauseBtn, true);
          // Resume periodic verification if day is on and not paused
          startPeriodicVerification();
        });

      // Periodic verification when free
      function startPeriodicVerification() {
        stopPeriodicVerification();
        if (!appState.dayStarted || appState.currentTrip || appState.paused)
          return;

        // V√©rifier inactivit√© pendant les heures de travail
        if (appState.currentSchedule?.active) {
          const now = new Date();
          if (isWithinWorkHours(now, appState.currentSchedule)) {
            const lastActivity =
              appState.lastActivityTime || appState.tripStartTime;
            if (lastActivity && Date.now() - lastActivity > 2 * 60 * 1000) {
              // 2 min
              logScheduleDeviation("inactive_during_hours", {
                lastActivity: new Date(
                  appState.lastActivityTime
                ).toLocaleTimeString(),
                currentTime: new Date().toLocaleTimeString(),
              });
            }
          }
        }

        appState.periodicTimerId = setTimeout(startPeriodicVerification, 60000); // toutes les 1 min
      }
      function stopPeriodicVerification() {
        if (appState.periodicTimerId) {
          clearTimeout(appState.periodicTimerId);
          appState.periodicTimerId = null;
        }
      }

      // Service Worker Registration avec code inline
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker
          .register("/sw.js")
          .then((registration) => console.log("SW registered"))
          .catch((error) => console.log("SW registration failed"));
      }

      // Test GPS simple au chargement
      function testGPSAvailability() {
        if (!navigator.geolocation) {
          console.error("‚ùå Geolocation non disponible");
          return;
        }

        console.log("üîç Test GPS au chargement...");
        navigator.geolocation.getCurrentPosition(
          (position) => {
            console.log("‚úÖ GPS fonctionne:", {
              lat: position.coords.latitude.toFixed(6),
              lng: position.coords.longitude.toFixed(6),
              accuracy: Math.round(position.coords.accuracy),
            });
          },
          (error) => {
            console.warn("‚ö†Ô∏è GPS non accessible:", error.message);
          },
          { timeout: 10000, maximumAge: 60000 }
        );
      }

      // Initialize app
      document.addEventListener("DOMContentLoaded", () => {
        console.log("üöÄ TaxiTracker avec GPS charg√©");

        window.addEventListener("online", () => {
          appState.isOnline = true;
          console.log("üü¢ Retour en ligne");
        });
        window.addEventListener("offline", () => {
          appState.isOnline = false;
          console.log("üî¥ Mode offline ‚Äî GPS seul");
        });

        // Mettre √† jour les statistiques quotidiennes
        async function updateDailyStats() {
          try {
            const todayStats = await statsRepository.getOrCreateToday();

            // Mettre √† jour l'affichage
            document.getElementById("daily-earnings").textContent =
              todayStats.totalEarnings.toLocaleString();
            document.getElementById("trip-count").textContent =
              todayStats.tripCount;

            console.log("üìä Stats mises √† jour:", todayStats.date);
          } catch (error) {
            console.error("‚ùå Erreur stats:", error);
          }
        }

        // Charger le planning de travail
        async function loadWorkSchedule() {
          try {
            const schedule = await workScheduleRepository.findByDriver(
              appState.currentOwnerId,
              appState.currentDriverId
            );
            appState.currentSchedule = schedule;
            console.log(
              "üìÖ Planning charg√©:",
              schedule?.workStartHour,
              "-",
              schedule?.workEndHour
            );
          } catch (e) {
            console.warn("‚ö†Ô∏è Pas de planning d√©fini");
          }
        }
        // V√©rifier utilisation hors planning au chargement
        if (appState.currentSchedule?.active) {
          const now = new Date();
          if (!isWithinWorkHours(now, appState.currentSchedule)) {
            logScheduleDeviation("worked_outside_hours", {
              time: now.toLocaleTimeString(),
              plannedRange: `${appState.currentSchedule.workStartHour}h‚Äì${appState.currentSchedule.workEndHour}h`,
            });
          }
        }
        loadWorkSchedule();

        // Appeler au chargement
        updateDailyStats();

        // Test GPS disponibilit√©
        if (navigator.geolocation) {
          console.log("‚úÖ API Geolocation disponible");
          testGPSAvailability();
        } else {
          console.error("‚ùå API Geolocation non disponible");
        }

        // Assurer l'√©tat visuel initial des boutons
        setButtonState(declareTripBtn, false);
        setButtonState(pauseBtn, false);
        pauseBtn.textContent = "‚è∏Ô∏è Pause";

        // Initialiser affichage GPS
        updateGPSStatus("D√©sactiv√©", "text-red-400");

        // D√©marrer le monitoring des zones
        startZoneMonitoring();

        // Test initial de zone si GPS d√©j√† disponible
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            (position) => {
              detectCurrentZone(
                position.coords.latitude,
                position.coords.longitude
              );
              updateZoneDisplay();
              console.log("üåç Zone initiale d√©tect√©e");
            },
            (error) => {
              console.log(
                "‚ö†Ô∏è Impossible de d√©tecter la zone initiale:",
                error.message
              );
            },
            { timeout: 5000, maximumAge: 60000 }
          );
        }

        // Event listeners pour l'historique
        // Charger l'historique au d√©marrage
        loadTripHistory();
        // Bouton actualiser historique
        document
          .getElementById("refresh-history-btn")
          .addEventListener("click", () => {
            console.log("üîÑ Actualisation historique...");
            loadTripHistory();
          });
        // Fermer le modal de d√©tails
        document
          .getElementById("close-trip-details")
          .addEventListener("click", () => {
            document
              .getElementById("trip-details-modal")
              .classList.add("hidden");
          });
        // Fermer le modal en cliquant √† l'ext√©rieur
        document
          .getElementById("trip-details-modal")
          .addEventListener("click", (e) => {
            if (e.target.id === "trip-details-modal") {
              document
                .getElementById("trip-details-modal")
                .classList.add("hidden");
            }
          });
      });

      // ===== SYST√àME D'HISTORIQUE DES COURSES =====

      // Mettre √† jour l'historique apr√®s chaque course termin√©e
      const originalEndTrip = document.getElementById("end-trip-btn").onclick;
      document
        .getElementById("end-trip-btn")
        .addEventListener("click", async () => {
          // Attendre un peu que la course soit sauvegard√©e
          setTimeout(() => {
            loadTripHistory();
          }, 1000);
        });

      // Charger et afficher l'historique
      async function loadTripHistory() {
        try {
          const trips = await tripRepository.findAll({
            ownerId: appState.currentOwnerId,
            driverId: appState.currentDriverId,
          });
          const completedTrips = trips.filter(
            (trip) => trip.status === "completed"
          );

          // Trier par date d√©croissante
          completedTrips.sort(
            (a, b) => new Date(b.startTime) - new Date(a.startTime)
          );

          const historyList = document.getElementById("trip-history-list");
          const historyCount = document.getElementById("trip-history-count");

          historyCount.textContent = `${completedTrips.length} course${
            completedTrips.length > 1 ? "s" : ""
          }`;

          if (completedTrips.length === 0) {
            historyList.innerHTML =
              '<p class="text-gray-500 text-sm text-center py-4">Aucune course enregistr√©e</p>';
            return;
          }

          historyList.innerHTML = completedTrips
            .map((trip) => {
              const startDate = new Date(trip.startTime);
              const duration = Math.round(trip.duration / 60000); // en minutes
              const distance = trip.distance; // en km
              return `
        <div class="bg-gray-700 rounded-lg p-3 cursor-pointer hover:bg-gray-600 transition-colors" 
             onclick="showTripDetails('${trip.id}')">
          <div class="flex items-center justify-between">
            <div class="flex-1">
              <div class="flex items-center justify-between mb-1">
                <span class="font-semibold text-green-400">${trip.amount.toLocaleString()} FCFA</span>
                <span class="text-xs text-gray-400">${startDate.toLocaleDateString()}</span>
                  </div>
              <div class="flex items-center justify-between text-sm text-gray-300">
                <span>${distance}km ‚Ä¢ ${duration}min</span>
                <span class="text-blue-400">${trip.zone}</span>
              </div>
              <div class="text-xs text-gray-400 mt-1">
                ${startDate.toLocaleTimeString()} ‚Ä¢ ${
                trip.passengers
              } passager${trip.passengers > 1 ? "s" : ""}
              </div>
            </div>
            <div class="ml-3 text-gray-400">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
              </svg>
            </div>
          </div>
        </div>
      `;
            })
            .join("");
          console.log(`üìã Historique charg√©: ${completedTrips.length} courses`);
        } catch (error) {
          console.error("‚ùå Erreur chargement historique:", error);
        }
      }

      // Afficher les d√©tails d'une course
      async function showTripDetails(tripId) {
        try {
          const trip = await tripRepository.findById(
            tripId,
            appState.currentOwnerId,
            appState.currentDriverId
          );
          if (!trip) {
            console.error("Course non trouv√©e:", tripId);
            return;
          }
          // Remplir les informations
          document.getElementById(
            "detail-amount"
          ).textContent = `${trip.amount.toLocaleString()} FCFA`;
          document.getElementById("detail-passengers").textContent =
            trip.passengers;
          document.getElementById("detail-zone").textContent = trip.zone;
          document.getElementById(
            "detail-distance"
          ).textContent = `${trip.distance} km`;
          document.getElementById(
            "detail-duration"
          ).textContent = `${Math.round(trip.duration / 60000)} min`;
          // Horaires
          const startDate = new Date(trip.startTime);
          const endDate = trip.endTime ? new Date(trip.endTime) : null;

          document.getElementById("detail-start-time").textContent =
            startDate.toLocaleTimeString();
          document.getElementById("detail-end-time").textContent = endDate
            ? endDate.toLocaleTimeString()
            : "En cours";
          document.getElementById("detail-date").textContent =
            startDate.toLocaleDateString();
          // Positions
          function formatPositionDisplay(pos, refTime) {
            if (!pos) return "Position non enregistr√©e";
            const now = Date.now();
            const ageMs = now - (pos.timestamp || refTime);
            const ageMin = Math.floor(ageMs / 60000);
            const ageLabel =
              ageMin > 0 ? `il y a ${ageMin} min` : "√† l'instant";
            const accuracyLabel = pos.accuracy
              ? `¬±${Math.round(pos.accuracy)}m`
              : "";
            const approxLabel = !pos.timestamp ? " (approximative)" : "";
            return `${pos.lat.toFixed(4)}, ${pos.lng.toFixed(
              4
            )} ‚Ä¢ ${accuracyLabel} ${ageLabel}${approxLabel}`;
          }

          document.getElementById("detail-start-position").textContent =
            formatPositionDisplay(trip.startPosition, trip.startTime);
          document.getElementById("detail-end-position").textContent =
            trip.endPosition
              ? formatPositionDisplay(trip.endPosition, trip.endTime)
              : "Non termin√©e";
          // Alertes
          const alertsSection = document.getElementById(
            "detail-alerts-section"
          );
          const alertsList = document.getElementById("detail-alerts-list");

          if (trip.fraudAlerts && trip.fraudAlerts.length > 0) {
            alertsSection.style.display = "block";
            alertsList.innerHTML = trip.fraudAlerts
              .map(
                (alert) => `
        <div class="flex items-center space-x-2">
          <span class="text-red-400">‚ö†Ô∏è</span>
          <span class="text-gray-300">${alert.message}</span>
          <span class="text-xs text-gray-500">${new Date(
            alert.timestamp
          ).toLocaleTimeString()}</span>
        </div>
      `
              )
              .join("");
          } else {
            alertsSection.style.display = "none";
          }

          // S'assurer que trip.gpsPoints existe (sinon, fallback sur ligne droite)
          if (!trip.gpsPoints || trip.gpsPoints.length < 2) {
            // Essayer de reconstruire √† partir de d√©part/arriv√©e
            if (trip.startPosition && trip.endPosition) {
              trip.gpsPoints = [trip.startPosition, trip.endPosition];
            } else if (trip.startPosition) {
              trip.gpsPoints = [trip.startPosition];
            } else {
              trip.gpsPoints = [];
            }
          }
          // Charger la carte
          await loadTripMap(trip);

          // Afficher le modal
          document
            .getElementById("trip-details-modal")
            .classList.remove("hidden");

          console.log("üìã D√©tails course affich√©s:", tripId);
        } catch (error) {
          console.error("‚ùå Erreur affichage d√©tails:", error);
        }
      }
      // Charger la carte avec trac√© de l'itin√©raire
      async function loadTripMap(trip) {
        const mapContainer = document.getElementById("trip-map");

        if (!trip.startPosition) {
          mapContainer.innerHTML = `
      <div class="absolute inset-0 flex items-center justify-center text-gray-400">
        <div class="text-center">
          <div class="text-4xl mb-2">üìç</div>
          <p>Aucune donn√©e GPS disponible</p>
        </div>
      </div>
    `;
          return;
        }
        // Cr√©er un ID unique pour cette carte
        const mapId = `map-${trip.id}`;

        // Pr√©parer le container pour Leaflet
        mapContainer.innerHTML = `
    <div id="${mapId}" class="w-full h-full rounded-lg"></div>
    <div class="absolute top-2 left-2 bg-black bg-opacity-70 text-white px-2 py-1 rounded text-xs z-10">
      üöó Trajet de la course
    </div>
    <div class="absolute bottom-2 right-2 bg-black bg-opacity-70 text-white px-2 py-1 rounded text-xs z-10">
      üìç ${(trip.distance / 1000).toFixed(1)}km ‚Ä¢ ${Math.round(
          trip.duration / 60000
        )}min
    </div>
  `;
        // Attendre que le DOM soit pr√™t
        setTimeout(() => {
          try {
            // Initialiser la carte Leaflet
            const map = L.map(mapId, {
              zoomControl: true,
              scrollWheelZoom: true,
              doubleClickZoom: true,
              boxZoom: true,
              keyboard: true,
            });
            // Ajouter les tuiles OpenStreetMap
            L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
              attribution: "¬© OpenStreetMap contributors",
              maxZoom: 19,
            }).addTo(map);

            // Marqueur de d√©part (vert)
            const startMarker = L.marker(
              [trip.startPosition.lat, trip.startPosition.lng],
              {
                icon: L.divIcon({
                  html: '<div style="background-color: #10b981; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                  className: "custom-marker",
                  iconSize: [20, 20],
                  iconAnchor: [10, 10],
                }),
              }
            ).addTo(map);
            startMarker.bindPopup(`
        <div class="text-center">
          <strong>üü¢ D√©part</strong><br>
          <small>${new Date(trip.startTime).toLocaleTimeString()}</small><br>
          <code>${trip.startPosition.lat.toFixed(
            6
          )}, ${trip.startPosition.lng.toFixed(6)}</code>
        </div>
      `);

            // Si on a une position d'arriv√©e, ajouter le marqueur et tracer la ligne
            if (trip.endPosition) {
              // Marqueur d'arriv√©e (rouge)
              const endMarker = L.marker(
                [trip.endPosition.lat, trip.endPosition.lng],
                {
                  icon: L.divIcon({
                    html: '<div style="background-color: #ef4444; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                    className: "custom-marker",
                    iconSize: [20, 20],
                    iconAnchor: [10, 10],
                  }),
                }
              ).addTo(map);
              endMarker.bindPopup(`
          <div class="text-center">
            <strong>üî¥ Arriv√©e</strong><br>
            <small>${
              trip.endTime
                ? new Date(trip.endTime).toLocaleTimeString()
                : "En cours"
            }</small><br>
            <code>${trip.endPosition.lat.toFixed(
              6
            )}, ${trip.endPosition.lng.toFixed(6)}</code>
          </div>
        `);

              // Tracer l'itin√©raire complet avec tous les points GPS
              const fullRoute = trip.gpsPoints.map((point) => [
                point.lat,
                point.lng,
              ]);
              const routeLine = L.polyline(fullRoute, {
                color: "#3b82f6",
                weight: 4,
                opacity: 0.8,
                smoothFactor: 1.0, // rend la ligne plus fluide
              }).addTo(map);

              // Optionnel : afficher des points interm√©diaires (ex: toutes les 10s)
              fullRoute.forEach((latlng, i) => {
                if (i % 5 === 0) {
                  L.circleMarker(latlng, { radius: 2, color: "#f59e0b" }).addTo(
                    map
                  );
                }
              });

              // Ajuster la vue pour inclure tous les points
              const groupItems = [routeLine];
              if (trip.startPosition) groupItems.push(startMarker);
              if (trip.endPosition) groupItems.push(endMarker);
              const group = new L.featureGroup(groupItems);
              map.fitBounds(group.getBounds().pad(0.1));
            } else {
              // Seulement le point de d√©part
              map.setView([trip.startPosition.lat, trip.startPosition.lng], 15);
            }

            console.log(`üó∫Ô∏è Carte charg√©e pour la course ${trip.id}`);
          } catch (error) {
            console.error("‚ùå Erreur chargement carte:", error);
            mapContainer.innerHTML = `
        <div class="absolute inset-0 flex items-center justify-center text-gray-400">
          <div class="text-center">
            <div class="text-4xl mb-2">‚ö†Ô∏è</div>
            <p>Erreur de chargement de la carte</p>
            <p class="text-xs mt-2">V√©rifiez votre connexion internet</p>
          </div>
        </div>
      `;
          }
        }, 100);
      }
    </script>
    <script>
      (function () {
        function c() {
          var b = a.contentDocument || a.contentWindow.document;
          if (b) {
            var d = b.createElement("script");
            d.innerHTML =
              "window.__CF$cv$params={r:'9872c26226e503fd',t:'MTc1OTIyNTIzMS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";
            b.getElementsByTagName("head")[0].appendChild(d);
          }
        }
        if (document.body) {
          var a = document.createElement("iframe");
          a.height = 1;
          a.width = 1;
          a.style.position = "absolute";
          a.style.top = 0;
          a.style.left = 0;
          a.style.border = "none";
          a.style.visibility = "hidden";
          document.body.appendChild(a);
          if ("loading" !== document.readyState) c();
          else if (window.addEventListener)
            document.addEventListener("DOMContentLoaded", c);
          else {
            var e = document.onreadystatechange || function () {};
            document.onreadystatechange = function (b) {
              e(b);
              "loading" !== document.readyState &&
                ((document.onreadystatechange = e), c());
            };
          }
        }
      })();
    </script>
  </body>
</html>
