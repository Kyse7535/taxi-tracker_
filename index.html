<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TaxiTracker 2 - Suivi Intelligent</title>
    <link rel="manifest" href="/manifest.json" />
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      rel="manifest"
      href="data:application/json;base64,eyJuYW1lIjoiVGF4aVRyYWNrZXIiLCJzaG9ydF9uYW1lIjoiVGF4aVRyYWNrZXIiLCJzdGFydF91cmwiOiIvIiwiZGlzcGxheSI6InN0YW5kYWxvbmUiLCJiYWNrZ3JvdW5kX2NvbG9yIjoiIzFmMjkzNyIsInRoZW1lX2NvbG9yIjoiIzM5OGVmNCIsImljb25zIjpbeyJzcmMiOiJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlOVEV5SWlCb1pXbG5hSFE5SWpVeE1pSWdkbWxsZDBKdmVEMGlNQ0F3SURVM01pQTFNVElpSUdacGJHdzlJaU16T1RobFpqUWlQanh5WldOMElIZzlJakV3TUNJZ2VUMGlNVEF3SWlCM2FXUjBhRDBpTXpFeUlpQm9aV2xuYUhROUlqTXhNaUlnY25nOUlqRTJJaUJtYVd4c1BTSWpabVptSWk4K1BDOXpkbWMrIiwic2l6ZXMiOiI1MTJ4NTEyIiwidHlwZSI6ImltYWdlL3N2Zyt4bWwifV19"
    />
    <style>
      .zoom-btn {
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .zoom-btn:hover {
        transform: scale(1.1);
      }
      .zoom-preset {
        transition: all 0.2s ease;
      }
      .zoom-preset:hover {
        transform: translateY(-1px);
      }
      .zoom-preset.active {
        background-color: #10b981;
      }
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap");
      body {
        font-family: "Inter", sans-serif;
        box-sizing: border-box;
      }
      .gradient-bg {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      }
      .glass {
        backdrop-filter: blur(10px);
        background: rgba(255, 255, 255, 0.1);
      }
      .pulse-dot {
        animation: pulse 2s infinite;
      }
      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }
      .camera-preview {
        aspect-ratio: 4/3;
        background: #1f2937;
        border-radius: 12px;
        position: relative;
        overflow: hidden;
      }
      .skeleton-overlay {
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 0, 0.3);
      }
      .gps-indicator {
        animation: gps-pulse 1.5s infinite;
      }
      @keyframes gps-pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }
    </style>
  </head>
  <body class="bg-gray-900 text-white min-h-screen">
    <!-- Header -->
    <header class="gradient-bg p-4 shadow-lg">
      <div class="flex items-center justify-between max-w-md mx-auto">
        <div class="flex items-center space-x-3">
          <div
            class="w-10 h-10 bg-white rounded-lg flex items-center justify-center"
          >
            <span class="text-2xl">üöñ</span>
          </div>
          <div>
            <h1 class="text-xl font-bold">TaxiTracker</h1>
            <p class="text-sm opacity-80">Chauffeur: Mbemba Jean</p>
          </div>
        </div>
        <div class="flex items-center space-x-2">
          <div id="gps-indicator" class="w-3 h-3 bg-red-400 rounded-full"></div>
          <div class="pulse-dot w-3 h-3 bg-green-400 rounded-full"></div>
          <span class="text-sm">En ligne</span>
        </div>
      </div>
    </header>

    <!-- Main Content -->
    <main class="max-w-md mx-auto p-4 space-y-6">
      <!-- GPS Status Card -->
      <div class="bg-gray-800 rounded-xl p-4 shadow-lg">
        <div class="flex items-center justify-between mb-2">
          <span class="font-medium">üìç Position GPS</span>
          <span id="gps-status" class="text-red-400 text-sm">D√©sactiv√©</span>
        </div>
        <div class="grid grid-cols-2 gap-4 text-sm">
          <div>
            <p class="text-gray-400">Pr√©cision</p>
            <p id="gps-accuracy" class="font-bold">-</p>
          </div>
          <div>
            <p class="text-gray-400">Vitesse</p>
            <p id="gps-speed" class="font-bold">-</p>
          </div>
        </div>
        <div class="mt-2">
          <p class="text-gray-400 text-xs">
            Points collect√©s: <span id="points-count">0</span>
          </p>
          <p class="text-gray-400 text-xs">
            Derni√®re position: <span id="last-position">-</span>
          </p>
        </div>
      </div>

      <!-- Status Card -->
      <div class="bg-gray-800 rounded-xl p-6 shadow-lg">
        <div class="flex items-center justify-between mb-4">
          <h2 class="text-lg font-semibold">Statut Actuel</h2>
          <span
            id="status-badge"
            class="px-3 py-1 bg-yellow-500 text-black rounded-full text-sm font-medium"
            >Libre</span
          >
        </div>
        <div class="grid grid-cols-2 gap-4 text-center">
          <div>
            <p class="text-2xl font-bold text-blue-400" id="daily-earnings">
              12,500
            </p>
            <p class="text-sm text-gray-400">FCFA aujourd'hui</p>
          </div>
          <div>
            <p class="text-2xl font-bold text-green-400" id="trip-count">8</p>
            <p class="text-sm text-gray-400">Courses</p>
          </div>
        </div>
      </div>

      <!-- Action Buttons -->
      <div class="space-y-3">
        <button
          id="start-day-btn"
          class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-4 px-6 rounded-xl transition-colors shadow-lg"
        >
          ‚ñ∂Ô∏è D√©marrer la journ√©e
        </button>

        <button
          id="declare-trip-btn"
          class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-4 px-6 rounded-xl transition-colors shadow-lg opacity-50 cursor-not-allowed"
          disabled
        >
          ‚ûï D√©clarer une course
        </button>

        <button
          id="pause-btn"
          class="w-full bg-orange-600 hover:bg-orange-700 text-white font-semibold py-4 px-6 rounded-xl transition-colors shadow-lg opacity-50 cursor-not-allowed"
          disabled
        >
          ‚è∏Ô∏è Pause
        </button>
      </div>

      <!-- Trip Declaration Modal -->
      <div
        id="trip-modal"
        class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center p-4 z-50"
      >
        <div class="bg-gray-800 rounded-xl p-6 w-full max-w-sm">
          <h3 class="text-xl font-bold mb-4">D√©clarer une course</h3>
          <div class="space-y-4">
            <div>
              <label class="block text-sm font-medium mb-2"
                >Montant (FCFA)</label
              >
              <input
                type="number"
                id="trip-amount"
                class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white"
                placeholder="ex: 1500"
              />
              <div class="mt-1">
                <p class="text-xs text-blue-400">
                  Prix estim√©:
                  <span id="estimated-price">Calcul√© automatiquement</span>
                </p>
              </div>
            </div>
            <div>
              <label class="block text-sm font-medium mb-2"
                >Nombre de passagers</label
              >
              <select
                id="passenger-count"
                class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white"
              >
                <option value="1">1 passager</option>
                <option value="2">2 passagers</option>
                <option value="3">3 passagers</option>
                <option value="4">4 passagers</option>
              </select>
            </div>
            <div class="flex space-x-3">
              <button
                id="cancel-trip"
                class="flex-1 bg-gray-600 hover:bg-gray-700 text-white py-2 px-4 rounded-lg transition-colors"
              >
                Annuler
              </button>
              <button
                id="start-trip"
                class="flex-1 bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded-lg transition-colors"
              >
                D√©marrer course
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Camera Verification Modal -->
      <div
        id="camera-modal"
        class="fixed inset-0 bg-black bg-opacity-90 hidden items-center justify-center p-4 z-50"
      >
        <div class="bg-gray-800 rounded-xl p-6 w-full max-w-sm">
          <h3 class="text-xl font-bold mb-4 text-center">üì∏ V√©rification IA</h3>
          <div class="camera-preview mb-4">
            <video
              id="camera-feed"
              class="w-full h-full object-cover rounded-lg"
              autoplay
              muted
            ></video>
            <div class="skeleton-overlay hidden" id="skeleton-overlay">
              <div class="flex items-center justify-center h-full">
                <div class="text-center">
                  <div class="w-16 h-16 mx-auto mb-2">
                    <!-- Skeleton figure -->
                    <svg
                      viewBox="0 0 100 100"
                      class="w-full h-full text-blue-400"
                    >
                      <circle cx="50" cy="20" r="8" fill="currentColor" />
                      <line
                        x1="50"
                        y1="28"
                        x2="50"
                        y2="70"
                        stroke="currentColor"
                        stroke-width="3"
                      />
                      <line
                        x1="35"
                        y1="40"
                        x2="65"
                        y2="40"
                        stroke="currentColor"
                        stroke-width="3"
                      />
                      <line
                        x1="50"
                        y1="70"
                        x2="35"
                        y2="90"
                        stroke="currentColor"
                        stroke-width="3"
                      />
                      <line
                        x1="50"
                        y1="70"
                        x2="65"
                        y2="90"
                        stroke="currentColor"
                        stroke-width="3"
                      />
                    </svg>
                  </div>
                  <p class="text-sm text-blue-400">Analyse en cours...</p>
                </div>
              </div>
            </div>
          </div>
          <div class="text-center">
            <p id="verification-message" class="text-lg font-medium mb-2">
              V√©rification dans <span id="countdown">5</span>s...
            </p>
            <p class="text-sm text-gray-400">
              Positionnez-vous bien dans le cadre
            </p>
          </div>
        </div>
      </div>

      <!-- Verification Result Modal -->
      <div
        id="result-modal"
        class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center p-4 z-50"
      >
        <div class="bg-gray-800 rounded-xl p-6 w-full max-w-sm text-center">
          <div id="result-icon" class="text-6xl mb-4">‚úÖ</div>
          <h3 id="result-title" class="text-xl font-bold mb-2">
            V√©rification r√©ussie
          </h3>
          <p id="result-message" class="text-gray-400 mb-4">
            2 passagers d√©tect√©s - Conforme √† la d√©claration
          </p>
          <button
            id="close-result"
            class="w-full bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded-lg transition-colors"
          >
            Continuer
          </button>
        </div>
      </div>

      <!-- Current Trip Card -->
      <div
        id="current-trip"
        class="bg-gray-800 rounded-xl p-6 shadow-lg hidden"
      >
        <div class="flex items-center justify-between mb-4">
          <h3 class="text-lg font-semibold">Course en cours</h3>
          <span
            class="px-3 py-1 bg-green-500 text-white rounded-full text-sm font-medium"
            >Active</span
          >
        </div>
        <div class="grid grid-cols-2 gap-4 mb-4">
          <div>
            <p class="text-sm text-gray-400">Montant d√©clar√©</p>
            <p class="text-lg font-bold text-green-400" id="current-amount">
              -
            </p>
          </div>
          <div>
            <p class="text-sm text-gray-400">Distance GPS</p>
            <p class="text-lg font-bold text-blue-400" id="current-distance">
              0.0 km
            </p>
          </div>
        </div>
        <div class="grid grid-cols-2 gap-4 mb-4">
          <div>
            <p class="text-sm text-gray-400">Dur√©e</p>
            <p class="text-xl font-bold text-white" id="trip-duration">00:00</p>
          </div>
          <div>
            <p class="text-sm text-gray-400">Prix estim√©</p>
            <p
              class="text-lg font-bold text-yellow-400"
              id="estimated-current-price"
            >
              -
            </p>
          </div>
        </div>
        <button
          id="end-trip-btn"
          class="w-full bg-red-600 hover:bg-red-700 text-white font-semibold py-3 px-6 rounded-lg transition-colors"
        >
          Terminer la course
        </button>
      </div>

      <!-- Fraud Alerts -->
      <div id="fraud-alerts" class="space-y-2 hidden">
        <div class="bg-red-900 border border-red-600 rounded-lg p-3">
          <div class="flex items-center space-x-2">
            <span class="text-red-400">‚ö†Ô∏è</span>
            <span class="text-sm font-medium">Alerte Fraude</span>
          </div>
          <p id="fraud-message" class="text-xs text-red-300 mt-1">-</p>
        </div>
      </div>

      <!-- Zone Status -->
      <div class="bg-gray-800 rounded-xl p-4 shadow-lg">
        <div class="flex items-center justify-between">
          <div class="flex items-center space-x-3">
            <span class="text-2xl">üìç</span>
            <div>
              <p class="font-medium">Zone Pointe-Noire</p>
              <p class="text-sm text-green-400">Dans la zone autoris√©e</p>
            </div>
          </div>
          <div class="w-3 h-3 bg-green-400 rounded-full"></div>
        </div>
      </div>

      <!-- Score de confiance -->
      <div class="bg-gray-800 rounded-xl p-4 shadow-lg">
        <div class="flex items-center justify-between mb-2">
          <span class="font-medium">Score de confiance</span>
          <span id="trust-score" class="text-green-400 font-bold">94%</span>
        </div>
        <div class="w-full bg-gray-700 rounded-full h-2">
          <div
            id="trust-bar"
            class="bg-green-400 h-2 rounded-full"
            style="width: 94%"
          ></div>
        </div>
        <p class="text-xs text-gray-400 mt-1">
          Excellent comportement ce mois-ci
        </p>
      </div>

      <!-- Carte GPS -->
      <div class="bg-gray-800 rounded-xl p-4 shadow-lg">
        <div class="flex items-center justify-between mb-4">
          <span class="font-medium">üó∫Ô∏è Carte GPS</span>
          <button
            id="toggle-map"
            class="text-blue-400 text-sm hover:text-blue-300"
          >
            Afficher
          </button>
        </div>
        <div id="map-container" class="hidden">
          <div
            id="gps-map"
            class="w-full h-64 bg-gray-700 rounded-lg relative overflow-hidden"
          >
            <!-- Carte SVG simple -->
            <svg id="map-svg" class="w-full h-full" viewBox="0 0 400 256">
              <!-- Grille de fond -->
              <defs>
                <pattern
                  id="grid"
                  width="20"
                  height="20"
                  patternUnits="userSpaceOnUse"
                >
                  <path
                    d="M 20 0 L 0 0 0 20"
                    fill="none"
                    stroke="#374151"
                    stroke-width="0.5"
                  />
                </pattern>
              </defs>
              <rect width="100%" height="100%" fill="url(#grid)" />

              <!-- Points GPS seront ajout√©s ici -->
              <g id="gps-points"></g>

              <!-- Trajet actuel -->
              <g id="current-trip-path"></g>

              <!-- Position actuelle -->
              <g id="current-position"></g>
            </svg>

            <!-- L√©gende -->
            <div
              class="absolute top-2 left-2 bg-black bg-opacity-70 rounded p-2 text-xs"
            >
              <div class="flex items-center space-x-1 mb-1">
                <div class="w-2 h-2 bg-blue-400 rounded-full"></div>
                <span>Points GPS</span>
              </div>
              <div class="flex items-center space-x-1 mb-1">
                <div class="w-2 h-2 bg-green-400 rounded-full"></div>
                <span>Position actuelle</span>
              </div>
              <div class="flex items-center space-x-1">
                <div class="w-3 h-0.5 bg-red-400"></div>
                <span>Trajet course</span>
              </div>
            </div>

            <!-- Stats carte -->
            <div
              class="absolute bottom-2 right-2 bg-black bg-opacity-70 rounded p-2 text-xs"
            >
              <div>Points: <span id="map-points-count">0</span></div>
              <div>Distance: <span id="map-distance">0.0 km</span></div>
            </div>
          </div>

          <!-- Contr√¥les carte -->
          <div
            class="flex flex-wrap justify-between items-center mt-2 text-sm space-x-1"
          >
            <div class="flex space-x-2">
              <button
                id="center-map"
                class="bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded text-xs"
              >
                Centrer
              </button>
              <button
                id="clear-map"
                class="bg-red-600 hover:bg-red-700 px-3 py-1 rounded text-xs"
              >
                Effacer
              </button>
            </div>
            <button
              id="zoom-out"
              class="zoom-btn bg-gray-600 hover:bg-gray-500 w-8 h-8 rounded-full text-xs font-bold"
            >
              ‚àí
            </button>
            <button
              id="zoom-ville"
              class="zoom-preset bg-purple-600 hover:bg-purple-700 px-2 py-1 rounded text-xs"
            >
              Ville
            </button>
            <button
              id="zoom-quartier"
              class="zoom-preset bg-indigo-600 hover:bg-indigo-700 px-2 py-1 rounded text-xs"
            >
              Quartier
            </button>
            <button
              id="zoom-rue"
              class="zoom-preset bg-blue-600 hover:bg-blue-700 px-2 py-1 rounded text-xs"
            >
              Rue
            </button>
            <button
              id="zoom-in"
              class="zoom-btn bg-gray-600 hover:bg-gray-500 w-8 h-8 rounded-full text-xs font-bold"
            >
              +
            </button>
            <div class="text-gray-400">
              Zoom: <span id="map-zoom">1.0x</span>
            </div>
          </div>
        </div>
      </div>
    </main>

    <script>
      // ===== ENTIT√âS M√âTIER =====

      // Entit√© Course
      class Trip {
        constructor(data = {}) {
          this.id = data.id || this.generateId();
          this.amount = data.amount || 0;
          this.passengers = data.passengers || 1;
          this.startPosition = data.startPosition || null;
          this.endPosition = data.endPosition || null;
          this.startTime = data.startTime || Date.now();
          this.endTime = data.endTime || null;
          this.distance = data.distance || 0;
          this.duration = data.duration || 0;
          this.zone = data.zone || "default";
          this.status = data.status || "active"; // active, completed, cancelled
          this.estimatedPrice = data.estimatedPrice || 0;
          this.fraudAlerts = data.fraudAlerts || [];
          this.createdAt = data.createdAt || new Date().toISOString();
          this.updatedAt = data.updatedAt || null;
        }
        generateId() {
          return (
            "trip_" +
            Date.now().toString(36) +
            Math.random().toString(36).substr(2)
          );
        }

        complete(endPosition, distance, duration) {
          this.endPosition = endPosition;
          this.endTime = Date.now();
          this.distance = distance;
          this.duration = duration;
          this.status = "completed";
          this.updatedAt = new Date().toISOString();
        }
        addFraudAlert(alert) {
          this.fraudAlerts.push({
            message: alert,
            timestamp: Date.now(),
          });
          this.updatedAt = new Date().toISOString();
        }

        toJSON() {
          return { ...this };
        }
      }

      // Entit√© Point GPS
      class GPSPoint {
        constructor(data = {}) {
          this.id = data.id || this.generateId();
          this.lat = data.lat || 0;
          this.lng = data.lng || 0;
          this.accuracy = data.accuracy || 0;
          this.speed = data.speed || 0;
          this.heading = data.heading || 0;
          this.altitude = data.altitude || 0;
          this.tripId = data.tripId || null;
          this.provider = data.provider || "html5";
          this.timestamp = data.timestamp || new Date().toISOString();
        }

        generateId() {
          return (
            "gps_" +
            Date.now().toString(36) +
            Math.random().toString(36).substr(2)
          );
        }

        toJSON() {
          return { ...this };
        }
      }

      // Entit√© Statistiques
      class DailyStats {
        constructor(data = {}) {
          this.id = data.id || this.generateId();
          this.date = data.date || new Date().toISOString().split("T")[0];
          this.totalEarnings = data.totalEarnings || 0;
          this.tripCount = data.tripCount || 0;
          this.totalDistance = data.totalDistance || 0;
          this.totalDuration = data.totalDuration || 0;
          this.averageTrip = data.averageTrip || 0;
          this.fraudAlerts = data.fraudAlerts || 0;
          this.zones = data.zones || {};
          this.createdAt = data.createdAt || new Date().toISOString();
          this.updatedAt = data.updatedAt || null;
        }

        generateId() {
          return "stats_" + this.date;
        }
        updateFromTrip(trip) {
          this.totalEarnings += trip.amount;
          this.tripCount += 1;
          this.totalDistance += trip.distance;
          this.totalDuration += trip.duration;
          this.averageTrip = this.totalEarnings / this.tripCount;
          this.fraudAlerts += trip.fraudAlerts.length;

          // Compter par zone
          this.zones[trip.zone] = (this.zones[trip.zone] || 0) + 1;

          this.updatedAt = new Date().toISOString();
        }
        toJSON() {
          return { ...this };
        }
      }

      // ===== INTERFACES REPOSITORY =====

      // Interface Repository g√©n√©rique
      class IRepository {
        async save(entity) {
          throw new Error("Not implemented");
        }
        async findById(id) {
          throw new Error("Not implemented");
        }
        async findAll(filters = {}) {
          throw new Error("Not implemented");
        }
        async update(id, updates) {
          throw new Error("Not implemented");
        }
        async delete(id) {
          throw new Error("Not implemented");
        }
        async count(filters = {}) {
          throw new Error("Not implemented");
        }
      }
      // ===== IMPL√âMENTATIONS LOCALSTORAGE =====

      // Repository Course
      class TripRepository extends IRepository {
        constructor() {
          super();
          this.storageKey = "taxitracker_trips";
          this.initStorage();
        }
        initStorage() {
          if (!localStorage.getItem(this.storageKey)) {
            localStorage.setItem(this.storageKey, JSON.stringify([]));
          }
        }

        async save(trip) {
          const trips = await this.findAll();
          const tripEntity = trip instanceof Trip ? trip : new Trip(trip);

          trips.push(tripEntity.toJSON());
          localStorage.setItem(this.storageKey, JSON.stringify(trips));
          console.log("üíæ Course sauvegard√©e:", tripEntity.id);
          return tripEntity;
        }

        async findById(id) {
          const trips = await this.findAll();
          const tripData = trips.find((t) => t.id === id);
          return tripData ? new Trip(tripData) : null;
        }
        async findAll(filters = {}) {
          const trips = JSON.parse(
            localStorage.getItem(this.storageKey) || "[]"
          );

          if (Object.keys(filters).length === 0) return trips;

          return trips.filter((trip) => {
            if (filters.date) {
              const tripDate = new Date(trip.createdAt).toDateString();
              const filterDate = new Date(filters.date).toDateString();
              if (tripDate !== filterDate) return false;
            }
            if (filters.status && trip.status !== filters.status) return false;
            return true;
          });
        }
        async update(id, updates) {
          const trips = await this.findAll();
          const index = trips.findIndex((t) => t.id === id);

          if (index === -1) throw new Error(`Course ${id} non trouv√©e`);

          trips[index] = {
            ...trips[index],
            ...updates,
            updatedAt: new Date().toISOString(),
          };
          localStorage.setItem(this.storageKey, JSON.stringify(trips));
          return new Trip(trips[index]);
        }

        async count(filters = {}) {
          const trips = await this.findAll(filters);
          return trips.length;
        }
        async exportCSV() {
          const trips = await this.findAll();
          if (!trips.length) return "Aucune course enregistr√©e";

          const headers = [
            "Date",
            "Heure",
            "Montant",
            "Passagers",
            "Distance",
            "Dur√©e",
            "Zone",
            "Statut",
          ];
          const rows = trips.map((trip) => [
            new Date(trip.createdAt).toLocaleDateString("fr-FR"),
            new Date(trip.createdAt).toLocaleTimeString("fr-FR"),
            trip.amount + " FCFA",
            trip.passengers,
            (trip.distance || 0).toFixed(2) + " km",
            Math.round((trip.duration || 0) / 60) + " min",
            trip.zone,
            trip.status,
          ]);

          return [headers, ...rows].map((row) => row.join(";")).join("\n");
        }
      }
      // Repository GPS
      class GPSRepository extends IRepository {
        constructor() {
          super();
          this.storageKey = "taxitracker_gps";
          this.maxPoints = 5000;
          this.initStorage();
        }

        initStorage() {
          if (!localStorage.getItem(this.storageKey)) {
            localStorage.setItem(this.storageKey, JSON.stringify([]));
          }
        }

        async save(point) {
          const points = await this.findAll();
          const pointEntity =
            point instanceof GPSPoint ? point : new GPSPoint(point);

          points.push(pointEntity.toJSON());

          // Limiter le nombre de points
          if (points.length > this.maxPoints) {
            points.splice(0, points.length - this.maxPoints);
          }
          localStorage.setItem(this.storageKey, JSON.stringify(points));
          return pointEntity;
        }

        async findAll(filters = {}) {
          const points = JSON.parse(
            localStorage.getItem(this.storageKey) || "[]"
          );

          if (Object.keys(filters).length === 0) return points;

          return points.filter((point) => {
            if (filters.tripId && point.tripId !== filters.tripId) return false;
            if (filters.date) {
              const pointDate = new Date(point.timestamp).toDateString();
              const filterDate = new Date(filters.date).toDateString();
              if (pointDate !== filterDate) return false;
            }
            return true;
          });
        }
        async findByTripId(tripId) {
          return this.findAll({ tripId });
        }

        async clearOldPoints(daysToKeep = 30) {
          const cutoffDate = new Date();
          cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);

          const points = await this.findAll();
          const filteredPoints = points.filter(
            (point) => new Date(point.timestamp) > cutoffDate
          );

          localStorage.setItem(this.storageKey, JSON.stringify(filteredPoints));
          console.log(
            `üßπ ${points.length - filteredPoints.length} points GPS supprim√©s`
          );
        }
      }
      // Repository Statistiques
      class StatsRepository extends IRepository {
        constructor() {
          super();
          this.storageKey = "taxitracker_stats";
          this.initStorage();
        }

        initStorage() {
          if (!localStorage.getItem(this.storageKey)) {
            localStorage.setItem(this.storageKey, JSON.stringify([]));
          }
        }
        async save(stats) {
          const allStats = await this.findAll();
          const statsEntity =
            stats instanceof DailyStats ? stats : new DailyStats(stats);

          // Remplacer si existe d√©j√† pour cette date
          const existingIndex = allStats.findIndex(
            (s) => s.date === statsEntity.date
          );
          if (existingIndex >= 0) {
            allStats[existingIndex] = statsEntity.toJSON();
          } else {
            allStats.push(statsEntity.toJSON());
          }

          localStorage.setItem(this.storageKey, JSON.stringify(allStats));
          return statsEntity;
        }
        async findByDate(date) {
          const dateStr =
            typeof date === "string" ? date : date.toISOString().split("T")[0];
          const allStats = await this.findAll();
          const statsData = allStats.find((s) => s.date === dateStr);
          return statsData ? new DailyStats(statsData) : null;
        }

        async findAll() {
          return JSON.parse(localStorage.getItem(this.storageKey) || "[]");
        }

        async getOrCreateToday() {
          const today = new Date().toISOString().split("T")[0];
          let stats = await this.findByDate(today);

          if (!stats) {
            stats = new DailyStats({ date: today });
            await this.save(stats);
          }

          return stats;
        }
      }
      // ===== INSTANCES GLOBALES =====
      const tripRepository = new TripRepository();
      const gpsRepository = new GPSRepository();
      const statsRepository = new StatsRepository();

      // ===== SYST√àME DE ZONES G√âOGRAPHIQUES =====

      // D√©finition des zones autoris√©es
      const AUTHORIZED_ZONES = {
        "pointe-noire": {
          name: "Pointe-Noire",
          center: { lat: -4.7692, lng: 11.8636 },
          radius: 25000, // 25km de rayon
          districts: [
            { name: "Centre-ville", lat: -4.7692, lng: 11.8636, radius: 3000 },
            { name: "Ti√©-Ti√©", lat: -4.75, lng: 11.85, radius: 2000 },
            { name: "Loandjili", lat: -4.8, lng: 11.88, radius: 2500 },
            { name: "Mongo-Mpoukou", lat: -4.73, lng: 11.84, radius: 2000 },
            { name: "Ngoyo", lat: -4.78, lng: 11.9, radius: 1500 },
            { name: "Vindoulou", lat: -4.74, lng: 11.87, radius: 1800 },
            { name: "Mpita", lat: -4.76, lng: 11.85, radius: 1500 },
          ],
        },
      };

      // Villes voisines pour r√©f√©rence
      const NEARBY_CITIES = [
        { name: "Dolisie", lat: -4.1989, lng: 12.6664 },
        { name: "Brazzaville", lat: -4.2634, lng: 15.2429 },
        { name: "Cabinda", lat: -5.55, lng: 12.2 },
        { name: "Luanda", lat: -8.839, lng: 13.2894 },
        { name: "Soyo", lat: -6.1364, lng: 12.3681 },
        { name: "Nzeto", lat: -7.2317, lng: 12.8644 },
      ];

      // √âtat de la zone actuelle
      let currentZoneStatus = {
        city: "Localisation...",
        district: null,
        authorized: false,
        distance: 0,
        lastUpdate: null,
      };

      // D√©tecter la zone actuelle
      function detectCurrentZone(lat, lng) {
        console.log(
          `üåç D√©tection zone pour: ${lat.toFixed(6)}, ${lng.toFixed(6)}`
        );

        // V√©rifier Pointe-Noire
        const pnZone = AUTHORIZED_ZONES["pointe-noire"];
        const distanceToPN = calculateDistance(
          lat,
          lng,
          pnZone.center.lat,
          pnZone.center.lng
        );

        if (distanceToPN <= pnZone.radius) {
          // Dans Pointe-Noire - d√©tecter le quartier
          let closestDistrict = null;
          let minDistance = Infinity;

          pnZone.districts.forEach((district) => {
            const distanceToDistrict = calculateDistance(
              lat,
              lng,
              district.lat,
              district.lng
            );
            if (
              distanceToDistrict <= district.radius &&
              distanceToDistrict < minDistance
            ) {
              minDistance = distanceToDistrict;
              closestDistrict = district.name;
            }
          });
          currentZoneStatus = {
            city: "Pointe-Noire",
            district: closestDistrict || "Zone p√©riph√©rique",
            authorized: true,
            distance: Math.round((distanceToPN / 1000) * 10) / 10,
            lastUpdate: Date.now(),
          };

          console.log("‚úÖ Zone autoris√©e:", currentZoneStatus);
          return currentZoneStatus;
        }

        // V√©rifier villes voisines
        let closestCity = null;
        let minCityDistance = Infinity;

        NEARBY_CITIES.forEach((city) => {
          const distance = calculateDistance(lat, lng, city.lat, city.lng);
          if (distance < minCityDistance) {
            minCityDistance = distance;
            closestCity = city.name;
          }
        });
        // Si proche d'une ville connue (< 50km)
        if (minCityDistance < 50000) {
          currentZoneStatus = {
            city: closestCity,
            district: null,
            authorized: false,
            distance: Math.round((distanceToPN / 1000) * 10) / 10,
            lastUpdate: Date.now(),
          };
        } else {
          // Zone inconnue
          currentZoneStatus = {
            city: "Zone inconnue",
            district: null,
            authorized: false,
            distance: Math.round((distanceToPN / 1000) * 10) / 10,
            lastUpdate: Date.now(),
          };
        }

        console.log("‚ùå Zone non autoris√©e:", currentZoneStatus);
        return currentZoneStatus;
      }

      // Mettre √† jour l'affichage de la zone
      function updateZoneDisplay() {
        console.log("üñ•Ô∏è Mise √† jour affichage zone...");

        // Trouver le conteneur de zone par son contenu
        const allContainers = document.querySelectorAll(
          ".bg-gray-800.rounded-xl.p-4.shadow-lg"
        );
        let zoneContainer = null;

        allContainers.forEach((container) => {
          const text = container.textContent;
          if (
            text.includes("Zone") ||
            text.includes("üìç") ||
            text.includes("Pointe-Noire")
          ) {
            zoneContainer = container;
          }
        });
        if (!zoneContainer) {
          console.warn("‚ö†Ô∏è Conteneur de zone non trouv√©");
          return;
        }
        // Reconstruire le contenu de la zone
        if (currentZoneStatus.authorized) {
          // Zone autoris√©e - vert
          zoneContainer.innerHTML = `
            <div class="flex items-center justify-between">
              <div class="flex items-center space-x-3">
                <span class="text-2xl">üìç</span>
                <div>
                  <p class="font-medium">${currentZoneStatus.city}</p>
                  <p class="text-sm text-green-400">
                    ${
                      currentZoneStatus.district
                        ? currentZoneStatus.district + " ‚Ä¢ "
                        : ""
                    }Zone autoris√©e
                  </p>
                </div>
              </div>
              <div class="w-3 h-3 bg-green-400 rounded-full"></div>
            </div>
          `;
        } else {
          // Zone non autoris√©e - rouge
          zoneContainer.innerHTML = `
            <div class="flex items-center justify-between">
              <div class="flex items-center space-x-3">
                <span class="text-2xl">‚ö†Ô∏è</span>
                <div>
                  <p class="font-medium">${currentZoneStatus.city}</p>
                  <p class="text-sm text-red-400">
                    Zone non autoris√©e ‚Ä¢ ${currentZoneStatus.distance}km de Pointe-Noire
                  </p>
                </div>
              </div>
              <div class="w-3 h-3 bg-red-400 rounded-full"></div>
            </div>
          `;

          // Alerte si en service dans une zone non autoris√©e
          if (
            appState.dayStarted &&
            !appState.paused &&
            !appState.currentTrip
          ) {
            addFraudAlert(`Service actif hors zone: ${currentZoneStatus.city}`);
          }
        }
        console.log("‚úÖ Affichage zone mis √† jour:", currentZoneStatus.city);
      }
      // V√©rification p√©riodique de la zone
      function startZoneMonitoring() {
        console.log("üîÑ D√©marrage monitoring des zones...");

        setInterval(() => {
          if (appState.currentPosition && appState.dayStarted) {
            const previousCity = currentZoneStatus.city;
            const previousAuthorized = currentZoneStatus.authorized;

            detectCurrentZone(
              appState.currentPosition.lat,
              appState.currentPosition.lng
            );

            // Mettre √† jour si changement significatif
            if (
              currentZoneStatus.city !== previousCity ||
              currentZoneStatus.authorized !== previousAuthorized
            ) {
              updateZoneDisplay();

              // Log du changement de zone
              if (
                previousCity !== "Localisation..." &&
                currentZoneStatus.city !== previousCity
              ) {
                console.log(
                  `üöó Changement de zone: ${previousCity} ‚Üí ${currentZoneStatus.city}`
                );
              }
            }
          }
        }, 15000); // V√©rifier toutes les 15 secondes
      }

      // Initialiser l'affichage de zone au d√©marrage
      function initializeZoneDisplay() {
        console.log("üèÅ Initialisation affichage zone...");

        // Affichage initial
        currentZoneStatus = {
          city: "Localisation...",
          district: null,
          authorized: false,
          distance: 0,
          lastUpdate: null,
        };

        updateZoneDisplay();
      }
      // ===== GPS TRACKING SYSTEM SIMPLIFI√â =====

      // Configuration GPS
      const GPS_CONFIG = {
        highAccuracy: true,
        timeout: 15000,
        maximumAge: 5000,
      };

      // Zones tarifaires Pointe-Noire
      const PRICING_ZONES = {
        "centre-ville": { base: 500, perKm: 400, perMin: 25 },
        banlieue: { base: 300, perKm: 250, perMin: 15 },
        aeroport: { base: 1000, perKm: 500, perMin: 30 },
        port: { base: 800, perKm: 350, perMin: 20 },
        "hors-zone": { base: 1500, perKm: 800, perMin: 50 }, // NOUVEAU - Tarif major√©
        default: { base: 400, perKm: 300, perMin: 20 },
      };

      // App State avec GPS
      let appState = {
        dayStarted: false,
        paused: false,
        currentTrip: null,
        tripStartTime: null,
        dailyEarnings: 12500,
        tripCount: 8,
        cameraStream: null,
        periodicTimerId: null,
        // GPS Tracking State
        gpsWatchId: null,
        currentPosition: null,
        positionBuffer: [],
        tripPoints: [],
        lastValidPosition: null,
        trackingActive: false,
        totalDistance: 0,
        // Fraud Detection
        suspiciousEvents: [],
        lastSpeedCheck: null,
        trustScore: 94,
      };

      // ===== UTILITAIRES GPS =====

      // Calcul distance Haversine (en m√®tres)
      function calculateDistance(lat1, lng1, lat2, lng2) {
        const R = 6371000; // Rayon terre en m√®tres
        const dLat = ((lat2 - lat1) * Math.PI) / 180;
        const dLng = ((lng2 - lng1) * Math.PI) / 180;
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos((lat1 * Math.PI) / 180) *
            Math.cos((lat2 * Math.PI) / 180) *
            Math.sin(dLng / 2) *
            Math.sin(dLng / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      // ===== SYST√àME DE CARTE GPS =====

      // √âtat de la carte
      let mapState = {
        visible: false,
        bounds: { minLat: null, maxLat: null, minLng: null, maxLng: null },
        zoom: 1.0,
        center: { lat: -4.7692, lng: 11.8636 }, // Pointe-Noire
        svgWidth: 400,
        svgHeight: 256,
        margin: 20, // Marge pour √©viter les points sur les bords
      };

      // Calculer les limites de tous les points
      function calculateMapBounds() {
        // Si on a des limites de zoom d√©finies, les utiliser
        if (mapState.bounds && mapState.bounds.minLat !== null) {
          return mapState.bounds;
        }

        // Sinon, calculer automatiquement
        const allPoints = [...appState.positionBuffer];
        if (appState.currentPosition) {
          allPoints.push(appState.currentPosition);
        }

        if (allPoints.length === 0) {
          return {
            minLat: -4.78,
            maxLat: -4.76,
            minLng: 11.85,
            maxLng: 11.87,
          };
        }

        let minLat = allPoints[0].lat;
        let maxLat = allPoints[0].lat;
        let minLng = allPoints[0].lng;
        let maxLng = allPoints[0].lng;

        allPoints.forEach((point) => {
          minLat = Math.min(minLat, point.lat);
          maxLat = Math.max(maxLat, point.lat);
          minLng = Math.min(minLng, point.lng);
          maxLng = Math.max(maxLng, point.lng);
        });

        const latMargin = Math.max((maxLat - minLat) * 0.1, 0.001);
        const lngMargin = Math.max((maxLng - minLng) * 0.1, 0.001);

        return {
          minLat: minLat - latMargin,
          maxLat: maxLat + latMargin,
          minLng: minLng - lngMargin,
          maxLng: maxLng + lngMargin,
        };
      }
      // Convertir coordonn√©es GPS en coordonn√©es SVG
      function gpsToSVG(lat, lng) {
        const bounds = calculateMapBounds();

        const latRange = bounds.maxLat - bounds.minLat;
        const lngRange = bounds.maxLng - bounds.minLng;

        // Calculer position avec marge
        const x =
          mapState.margin +
          ((lng - bounds.minLng) / lngRange) *
            (mapState.svgWidth - 2 * mapState.margin);
        const y =
          mapState.margin +
          (1 - (lat - bounds.minLat) / latRange) *
            (mapState.svgHeight - 2 * mapState.margin);

        return {
          x: Math.max(
            mapState.margin,
            Math.min(mapState.svgWidth - mapState.margin, x)
          ),
          y: Math.max(
            mapState.margin,
            Math.min(mapState.svgHeight - mapState.margin, y)
          ),
        };
      }

      // Ajouter un point sur la carte
      function addPointToMap(lat, lng, type = "gps") {
        if (!mapState.visible) return;

        console.log(`üó∫Ô∏è Ajout point ${type}:`, {
          lat: lat.toFixed(6),
          lng: lng.toFixed(6),
        });

        const svgPos = gpsToSVG(lat, lng);
        console.log(`üìç Position SVG:`, svgPos);

        if (type === "current") {
          // Position actuelle - remplacer
          const currentGroup = document.getElementById("current-position");
          currentGroup.innerHTML = "";

          const circle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
          );
          circle.setAttribute("cx", svgPos.x);
          circle.setAttribute("cy", svgPos.y);
          circle.setAttribute("r", "5");
          circle.setAttribute("fill", "#10b981");
          circle.setAttribute("stroke", "#ffffff");
          circle.setAttribute("stroke-width", "2");
          circle.setAttribute("opacity", "1");

          // Animation pulse
          const animate = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "animate"
          );
          animate.setAttribute("attributeName", "r");
          animate.setAttribute("values", "5;8;5");
          animate.setAttribute("dur", "2s");
          animate.setAttribute("repeatCount", "indefinite");
          circle.appendChild(animate);

          currentGroup.appendChild(circle);
        } else {
          // Point GPS normal
          const pointsGroup = document.getElementById("gps-points");

          const circle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
          );
          circle.setAttribute("cx", svgPos.x);
          circle.setAttribute("cy", svgPos.y);
          circle.setAttribute("r", "2");
          circle.setAttribute("fill", "#60a5fa");
          circle.setAttribute("opacity", "0.8");

          pointsGroup.appendChild(circle);

          // Limiter le nombre de points (garder les plus r√©cents)
          while (pointsGroup.children.length > 200) {
            pointsGroup.removeChild(pointsGroup.firstChild);
          }
        }

        updateMapStats();
      }

      // Redessiner tous les points
      function redrawAllPoints() {
        console.log("üîÑ Redessinage de tous les points...");

        // Vider tous les groupes
        document.getElementById("gps-points").innerHTML = "";
        document.getElementById("current-position").innerHTML = "";
        document.getElementById("current-trip-path").innerHTML = "";

        // Redessiner points GPS
        appState.positionBuffer.forEach((point) => {
          const svgPos = gpsToSVG(point.lat, point.lng);

          const circle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
          );
          circle.setAttribute("cx", svgPos.x);
          circle.setAttribute("cy", svgPos.y);
          circle.setAttribute("r", "2");
          circle.setAttribute("fill", "#60a5fa");
          circle.setAttribute("opacity", "0.8");

          document.getElementById("gps-points").appendChild(circle);
        });

        // Redessiner position actuelle
        if (appState.currentPosition) {
          const svgPos = gpsToSVG(
            appState.currentPosition.lat,
            appState.currentPosition.lng
          );

          const circle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
          );
          circle.setAttribute("cx", svgPos.x);
          circle.setAttribute("cy", svgPos.y);
          circle.setAttribute("r", "5");
          circle.setAttribute("fill", "#10b981");
          circle.setAttribute("stroke", "#ffffff");
          circle.setAttribute("stroke-width", "2");

          // Animation pulse
          const animate = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "animate"
          );
          animate.setAttribute("attributeName", "r");
          animate.setAttribute("values", "5;8;5");
          animate.setAttribute("dur", "2s");
          animate.setAttribute("repeatCount", "indefinite");
          circle.appendChild(animate);

          document.getElementById("current-position").appendChild(circle);
        }

        // Redessiner trajet de course
        if (appState.currentTrip && appState.tripPoints.length > 1) {
          drawTripPath();
        }

        updateMapStats();
        console.log(`‚úÖ ${appState.positionBuffer.length} points redessin√©s`);
      }

      // Dessiner le trajet de la course
      function drawTripPath() {
        const pathGroup = document.getElementById("current-trip-path");
        pathGroup.innerHTML = "";

        if (appState.tripPoints.length < 2) return;

        let pathData = "";
        appState.tripPoints.forEach((point, index) => {
          const svgPos = gpsToSVG(point.lat, point.lng);
          pathData +=
            index === 0
              ? `M ${svgPos.x} ${svgPos.y}`
              : ` L ${svgPos.x} ${svgPos.y}`;
        });

        const path = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path"
        );
        path.setAttribute("d", pathData);
        path.setAttribute("stroke", "#ef4444");
        path.setAttribute("stroke-width", "3");
        path.setAttribute("fill", "none");
        path.setAttribute("opacity", "0.9");
        path.setAttribute("stroke-linecap", "round");
        path.setAttribute("stroke-linejoin", "round");

        pathGroup.appendChild(path);
        console.log(
          `üõ£Ô∏è Trajet dessin√© avec ${appState.tripPoints.length} points`
        );
      }

      // Mettre √† jour les statistiques de la carte
      function updateMapStats() {
        document.getElementById("map-points-count").textContent =
          appState.positionBuffer.length;

        if (appState.currentTrip && appState.tripPoints.length > 1) {
          const distance = calculateTripDistance();
          document.getElementById(
            "map-distance"
          ).textContent = `${distance.toFixed(2)} km`;
        } else {
          document.getElementById("map-distance").textContent = "0.0 km";
        }
      }

      // Centrer la carte sur la position actuelle
      function centerMap() {
        console.log("üéØ Centrage de la carte...");
        if (appState.positionBuffer.length > 0 || appState.currentPosition) {
          redrawAllPoints();
          console.log("‚úÖ Carte centr√©e");
        } else {
          console.log("‚ö†Ô∏è Aucun point GPS pour centrer");
          alert("Aucun point GPS disponible pour centrer la carte");
        }
      }

      // Effacer tous les points de la carte
      function clearMap() {
        console.log("üßπ Nettoyage de la carte...");

        if (confirm("Effacer tous les points GPS de la carte ?")) {
          document.getElementById("gps-points").innerHTML = "";
          document.getElementById("current-trip-path").innerHTML = "";
          document.getElementById("current-position").innerHTML = "";

          // R√©initialiser les donn√©es GPS
          appState.positionBuffer = [];
          appState.tripPoints = [];
          appState.currentPosition = null;

          updateMapStats();
          console.log("‚úÖ Carte nettoy√©e");
        }
      }

      // Toggle affichage carte
      function toggleMap() {
        const container = document.getElementById("map-container");
        const button = document.getElementById("toggle-map");

        mapState.visible = !mapState.visible;

        if (mapState.visible) {
          container.classList.remove("hidden");
          button.textContent = "Masquer";
          console.log("üó∫Ô∏è Carte affich√©e");

          // Dessiner tous les points existants
          redrawAllPoints();
        } else {
          container.classList.add("hidden");
          button.textContent = "Afficher";
          console.log("üó∫Ô∏è Carte masqu√©e");
        }
      }

      // ==================================================
      // üõ†Ô∏è FEATURE : G√âN√âRATION DE TRAJETS SIMUL√âS
      // Description : g√©n√®re des points coh√©rents entre deux positions GPS
      // ==================================================

      /**
       * G√©n√®re un trajet simul√© entre deux coordonn√©es
       * @param {number} startLat - Latitude d√©part
       * @param {number} startLng - Longitude d√©part
       * @param {number} endLat   - Latitude arriv√©e
       * @param {number} endLng   - Longitude arriv√©e
       * @param {number} steps    - Nombre de points interm√©diaires
       * @param {number} intervalSec - Intervalle temps (s) entre deux points
       */
      function generateSimulatedRoute(
        startLat,
        startLng,
        endLat,
        endLng,
        steps = 50,
        intervalSec = 5
      ) {
        const now = Date.now();
        const route = [];

        for (let i = 0; i <= steps; i++) {
          const t = i / steps; // interpolation [0,1]

          // Position interpol√©e
          let lat = startLat + t * (endLat - startLat);
          let lng = startLng + t * (endLng - startLng);

          // Ajout bruit GPS r√©aliste (~¬±10m)
          const noiseLat = (Math.random() - 0.5) * 0.0002; // ¬±0.0001¬∞
          const noiseLng = (Math.random() - 0.5) * 0.0002;

          lat += noiseLat;
          lng += noiseLng;

          route.push({
            lat,
            lng,
            ts: now + i * intervalSec * 1000, // timestamps progressifs
            accuracy: 5 + Math.random() * 10, // pr√©cision entre 5 et 15m
          });
        }

        return route;
      }

      // ==================================================
      // üöñ SIMULATION DE TRAJET PARIS : Gare de Lyon ‚Üí Tour Eiffel
      // ==================================================

      function simulateParisRoute() {
        const startLat = 48.8443,
          startLng = 2.373; // Gare de Lyon
        const endLat = 48.8584,
          endLng = 2.2945; // Tour Eiffel

        // G√©n√©rer un trajet avec 60 points
        const simulatedPoints = generateSimulatedRoute(
          startLat,
          startLng,
          endLat,
          endLng,
          60,
          5
        );

        // Injecter dans appState
        appState.positionBuffer = simulatedPoints;
        appState.currentPosition = simulatedPoints[simulatedPoints.length - 1];

        // Dessiner la trajectoire
        initMapWithPoints();

        console.log(
          "üó∫Ô∏è Trajet simul√© Paris : Gare de Lyon ‚Üí Tour Eiffel",
          simulatedPoints
        );
      }

      /**
       * Initialise la carte SVG avec les points existants (buffer + position actuelle)
       * - Reconstruit mapState.bounds si n√©cessaire
       * - Cr√©e les √©l√©ments SVG en lot pour √©viter trop de reflows
       * - Dessine la position actuelle et le trajet si en course
       */
      function initMapWithPoints() {
        // R√©fs SVG
        const gpsPointsGroup = document.getElementById("gps-points");
        const currentGroup = document.getElementById("current-position");
        const tripPathGroup = document.getElementById("current-trip-path");

        if (!gpsPointsGroup || !currentGroup || !tripPathGroup) return;

        // Reset visuel
        gpsPointsGroup.innerHTML = "";
        currentGroup.innerHTML = "";
        tripPathGroup.innerHTML = "";

        // Si on n'a pas de bounds yet, calculer √† partir du buffer + currentPosition
        if (appState.positionBuffer.length > 0 || appState.currentPosition) {
          // Recr√©er bounds en scannant les points existants
          let minLat = null,
            maxLat = null,
            minLng = null,
            maxLng = null;

          const scanPoints = appState.positionBuffer.slice(); // clonage l√©ger
          if (appState.currentPosition)
            scanPoints.push(appState.currentPosition);

          scanPoints.forEach((p) => {
            if (minLat === null) {
              minLat = maxLat = p.lat;
              minLng = maxLng = p.lng;
            } else {
              if (p.lat < minLat) minLat = p.lat;
              if (p.lat > maxLat) maxLat = p.lat;
              if (p.lng < minLng) minLng = p.lng;
              if (p.lng > maxLng) maxLng = p.lng;
            }
          });

          // Appliquer une petite marge (10%)
          const latMargin = (maxLat - minLat || 0.0001) * 0.1;
          const lngMargin = (maxLng - minLng || 0.0001) * 0.1;

          mapState.bounds = {
            minLat: minLat - latMargin,
            maxLat: maxLat + latMargin,
            minLng: minLng - lngMargin,
            maxLng: maxLng + lngMargin,
          };
        } else {
          // Si pas de points, on centre sur center par d√©faut
          mapState.bounds = {
            minLat: mapState.center.lat - 0.01,
            maxLat: mapState.center.lat + 0.01,
            minLng: mapState.center.lng - 0.01,
            maxLng: mapState.center.lng + 0.01,
          };
        }

        // Create points in a DocumentFragment for performance
        const fragment = document.createDocumentFragment();

        // Limiter le nombre de points affich√©s (par ex. 500)
        const pointsToRender = Math.min(appState.positionBuffer.length, 500);
        const startIndex = Math.max(
          0,
          appState.positionBuffer.length - pointsToRender
        );

        for (let i = startIndex; i < appState.positionBuffer.length; i++) {
          const p = appState.positionBuffer[i];
          const pos = gpsToSVG(p.lat, p.lng);

          const circle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
          );
          circle.setAttribute("cx", pos.x);
          circle.setAttribute("cy", pos.y);
          circle.setAttribute("r", "2");
          circle.setAttribute("fill", "#60a5fa");
          circle.setAttribute("opacity", "0.7");

          fragment.appendChild(circle);
        }

        // Append all gps points at once
        gpsPointsGroup.appendChild(fragment);

        // Si on a une position actuelle, la dessiner
        if (appState.currentPosition) {
          const curPos = gpsToSVG(
            appState.currentPosition.lat,
            appState.currentPosition.lng
          );

          const currentCircle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
          );
          currentCircle.setAttribute("cx", curPos.x);
          currentCircle.setAttribute("cy", curPos.y);
          currentCircle.setAttribute("r", "4");
          currentCircle.setAttribute("fill", "#10b981");
          currentCircle.setAttribute("opacity", "1");

          // ajout d'une animation de pulse simple via animate
          const animate = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "animate"
          );
          animate.setAttribute("attributeName", "r");
          animate.setAttribute("values", "4;6;4");
          animate.setAttribute("dur", "2s");
          animate.setAttribute("repeatCount", "indefinite");
          currentCircle.appendChild(animate);

          currentGroup.appendChild(currentCircle);
        }

        // Si une course est en cours, dessiner le trajet existant
        if (appState.currentTrip && appState.tripPoints.length > 1) {
          // Construire le path data
          let pathData = "";
          appState.tripPoints.forEach((point, idx) => {
            const svgPos = gpsToSVG(point.lat, point.lng);
            pathData +=
              idx === 0
                ? `M ${svgPos.x} ${svgPos.y}`
                : ` L ${svgPos.x} ${svgPos.y}`;
          });

          const path = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          path.setAttribute("d", pathData);
          path.setAttribute("stroke", "#ef4444");
          path.setAttribute("stroke-width", "2");
          path.setAttribute("fill", "none");
          path.setAttribute("opacity", "0.9");

          tripPathGroup.appendChild(path);
        }

        // Mettre √† jour stats affich√©es
        updateMapStats();
      }
      function simulateParisRouteMultiWaypointsDetailed() {
        // Points principaux de Paris
        const mainPoints = [
          { lat: 48.8566, lng: 2.3522 }, // Notre-Dame
          { lat: 48.8606, lng: 2.3376 }, // Louvre
          { lat: 48.864716, lng: 2.349014 }, // Op√©ra
          { lat: 48.8718, lng: 2.313 }, // Arc de Triomphe
          { lat: 48.8738, lng: 2.295 }, // Champs-√âlys√©es
          { lat: 48.866667, lng: 2.333333 }, // Montmartre
          { lat: 48.853, lng: 2.3499 }, // Sainte-Chapelle
          { lat: 48.8584, lng: 2.2945 }, // Tour Eiffel
        ];

        console.log("üöó Simulation trajet multi-waypoints Paris d√©taill√©");

        appState.positionBuffer = [];
        appState.tripPoints = [];

        // Parcourir chaque segment de waypoint
        for (let i = 0; i < mainPoints.length - 1; i++) {
          const start = mainPoints[i];
          const end = mainPoints[i + 1];

          // G√©n√©rer points interm√©diaires
          const intermediatePoints = generateSimulatedRoute(start, end, 10); // 10 points interm√©diaires

          intermediatePoints.forEach((p, index) => {
            const point = {
              lat: p.lat,
              lng: p.lng,
              ts: Date.now() + i * 10000 + index * 500, // spacing temporel
              accuracy: 5,
              speed: 15 + Math.random() * 5,
              heading: 0,
              provider: "simulation",
            };

            appState.positionBuffer.push(point);
            appState.tripPoints.push(point);

            if (mapState.visible)
              addPointToMap(point.lat, point.lng, "simulated");
          });
        }

        // Ajouter le dernier point principal
        const lastPoint = mainPoints[mainPoints.length - 1];
        const finalPoint = {
          lat: lastPoint.lat,
          lng: lastPoint.lng,
          ts: Date.now(),
          accuracy: 5,
          speed: 0,
          heading: 0,
          provider: "simulation",
        };
        appState.positionBuffer.push(finalPoint);
        appState.tripPoints.push(finalPoint);

        // Mettre √† jour l‚Äôaffichage GPS
        appState.currentPosition = {
          lat: finalPoint.lat,
          lng: finalPoint.lng,
          accuracy: 5,
        };
        updateGPSDisplay(appState.currentPosition);

        console.log(
          `‚úÖ Simulation multi-waypoints d√©taill√©e termin√©e: ${appState.positionBuffer.length} points`
        );
      }

      // ===== SYST√àME DE ZOOM =====

      // Niveaux de zoom pr√©d√©finis (en facteur de marge)
      const ZOOM_LEVELS = {
        ville: 0.5, // Vue large de la ville
        quartier: 0.2, // Vue quartier
        rue: 0.05, // Vue rapproch√©e
        auto: 0.1, // Zoom automatique par d√©faut
      };

      // Appliquer un niveau de zoom
      function applyZoom(level) {
        console.log(`üîç Application zoom: ${level}`);

        if (!mapState.visible) {
          console.log("‚ö†Ô∏è Carte non visible");
          return;
        }

        const allPoints = [...appState.positionBuffer];
        if (appState.currentPosition) {
          allPoints.push(appState.currentPosition);
        }

        if (allPoints.length === 0) {
          console.log("‚ö†Ô∏è Aucun point pour le zoom");
          return;
        }

        // Calculer nouvelles limites avec le facteur de zoom
        let minLat = allPoints[0].lat;
        let maxLat = allPoints[0].lat;
        let minLng = allPoints[0].lng;
        let maxLng = allPoints[0].lng;

        allPoints.forEach((point) => {
          minLat = Math.min(minLat, point.lat);
          maxLat = Math.max(maxLat, point.lat);
          minLng = Math.min(minLng, point.lng);
          maxLng = Math.max(maxLng, point.lng);
        });

        // Appliquer le facteur de zoom
        const zoomFactor = ZOOM_LEVELS[level] || ZOOM_LEVELS.auto;
        const latRange = Math.max(maxLat - minLat, 0.001);
        const lngRange = Math.max(maxLng - minLng, 0.001);

        const latMargin = latRange * zoomFactor;
        const lngMargin = lngRange * zoomFactor;

        // Mettre √† jour l'√©tat de la carte
        mapState.bounds = {
          minLat: minLat - latMargin,
          maxLat: maxLat + latMargin,
          minLng: minLng - lngMargin,
          maxLng: maxLng + lngMargin,
        };

        mapState.zoom = 1 / zoomFactor; // Facteur d'affichage

        // Redessiner avec le nouveau zoom
        redrawAllPoints();

        // Mettre √† jour l'affichage du zoom
        document.getElementById(
          "map-zoom"
        ).textContent = `${mapState.zoom.toFixed(1)}x`;

        // Mettre √† jour les boutons actifs
        updateZoomButtons(level);

        console.log(`‚úÖ Zoom ${level} appliqu√© (${mapState.zoom.toFixed(1)}x)`);
      }

      // Zoom manuel (+ et -)
      function manualZoom(direction) {
        const currentZoom = mapState.zoom;
        let newZoom;

        if (direction === "in") {
          newZoom = Math.min(currentZoom * 1.5, 60); // Max 10x
        } else {
          newZoom = Math.max(currentZoom / 1.5, 0.1); // Min 0.1x
        }

        // Calculer le facteur de marge correspondant
        const marginFactor = 1 / newZoom;

        // Appliquer le zoom personnalis√©
        const allPoints = [...appState.positionBuffer];
        if (appState.currentPosition) {
          allPoints.push(appState.currentPosition);
        }

        if (allPoints.length === 0) return;

        let minLat = allPoints[0].lat;
        let maxLat = allPoints[0].lat;
        let minLng = allPoints[0].lng;
        let maxLng = allPoints[0].lng;

        allPoints.forEach((point) => {
          minLat = Math.min(minLat, point.lat);
          maxLat = Math.max(maxLat, point.lat);
          minLng = Math.min(minLng, point.lng);
          maxLng = Math.max(maxLng, point.lng);
        });

        const latRange = Math.max(maxLat - minLat, 0.001);
        const lngRange = Math.max(maxLng - minLng, 0.001);

        const latMargin = latRange * marginFactor;
        const lngMargin = lngRange * marginFactor;

        mapState.bounds = {
          minLat: minLat - latMargin,
          maxLat: maxLat + latMargin,
          minLng: minLng - lngMargin,
          maxLng: maxLng + lngMargin,
        };

        mapState.zoom = newZoom;

        redrawAllPoints();
        document.getElementById(
          "map-zoom"
        ).textContent = `${mapState.zoom.toFixed(1)}x`;
        updateZoomButtons("manual");

        console.log(`üîç Zoom manuel: ${direction} ‚Üí ${newZoom.toFixed(1)}x`);
      }

      // Mettre √† jour l'apparence des boutons de zoom
      function updateZoomButtons(activeLevel) {
        // Retirer la classe active de tous les presets
        document.querySelectorAll(".zoom-preset").forEach((btn) => {
          btn.classList.remove("active");
        });

        // Ajouter la classe active au niveau s√©lectionn√©
        if (activeLevel !== "manual") {
          const activeBtn = document.getElementById(`zoom-${activeLevel}`);
          if (activeBtn) {
            activeBtn.classList.add("active");
          }
        }
      }

      // ===== SYST√àME DE TRACKING SIMPLIFI√â =====

      // D√©marrer tracking GPS
      function startGPSTracking() {
        console.log("üîÑ D√©marrage GPS tracking...");

        if (!navigator.geolocation) {
          console.error("‚ùå GPS non support√©");
          updateGPSStatus("Non support√©", "text-red-400");
          return false;
        }

        updateGPSStatus("D√©marrage...", "text-yellow-400");

        const options = {
          enableHighAccuracy: true,
          timeout: 15000,
          maximumAge: 5000,
        };

        console.log("üì° Lancement watchPosition...");

        appState.gpsWatchId = navigator.geolocation.watchPosition(
          (position) => {
            console.log("üéØ GPS SUCCESS:", {
              lat: position.coords.latitude.toFixed(6),
              lng: position.coords.longitude.toFixed(6),
              accuracy: Math.round(position.coords.accuracy),
              time: new Date().toLocaleTimeString(),
            });
            handleGPSSuccess(position);
          },
          (error) => {
            console.error("‚ùå GPS ERROR:", error.message);
            handleGPSError(error);
          },
          options
        );

        appState.trackingActive = true;
        console.log("‚úÖ WatchPosition lanc√©, ID:", appState.gpsWatchId);

        // Test timeout
        setTimeout(() => {
          if (appState.positionBuffer.length === 0) {
            console.log("‚è≥ Aucun point GPS re√ßu apr√®s 5s");
            updateGPSStatus("En attente signal...", "text-yellow-400");
          }
        }, 5000);

        return true;
      }

      // Arr√™ter tracking GPS
      function stopGPSTracking() {
        console.log("üõë Arr√™t GPS tracking...");
        if (appState.gpsWatchId) {
          navigator.geolocation.clearWatch(appState.gpsWatchId);
          appState.gpsWatchId = null;
        }

        appState.trackingActive = false;
        updateGPSStatus("D√©sactiv√©", "text-red-400");
        document.getElementById("gps-indicator").className =
          "w-3 h-3 bg-red-400 rounded-full";
      }

      // Succ√®s GPS
      function handleGPSSuccess(position) {
        // Mettre √† jour le statut imm√©diatement
        updateGPSStatus("Actif", "text-green-400");
        document.getElementById("gps-indicator").className =
          "gps-indicator w-3 h-3 bg-green-400 rounded-full";

        // Validation basique
        if (!position || !position.coords) {
          console.warn("‚ùå Position invalide");
          return;
        }

        const { latitude, longitude, accuracy } = position.coords;

        // V√©rifications de base
        if (Math.abs(latitude) > 90 || Math.abs(longitude) > 180) {
          console.warn("‚ùå Coordonn√©es invalides");
          return;
        }

        // Cr√©er le point GPS
        const point = {
          lat: latitude,
          lng: longitude,
          ts: Date.now(),
          accuracy: accuracy || 0,
          speed: position.coords.speed || 0,
          heading: position.coords.heading || 0,
          provider: "html5",
        };

        appState.currentPosition = point;
        appState.lastValidPosition = point;

        // Ajouter au buffer
        appState.positionBuffer.push(point);

        // Limiter taille buffer
        if (appState.positionBuffer.length > 1000) {
          appState.positionBuffer.shift();
        }

        // Si en course, ajouter aux points du trip
        if (appState.currentTrip) {
          appState.tripPoints.push(point);
          updateTripDistance();
          console.log(
            "üöó Point ajout√© √† la course, total:",
            appState.tripPoints.length
          );
        }

        // Mettre √† jour UI
        updateGPSDisplay(point);

        // D√©tecter et mettre √† jour la zone g√©ographique
        detectCurrentZone(point.lat, point.lng);
        updateZoneDisplay();

        // Ajouter √† la carte si visible
        if (mapState.visible) {
          addPointToMap(point.lat, point.lng, "current");
        }
        addPointToMap(point.lat, point.lng, "current");

        console.log(
          "‚úÖ Point GPS trait√© - Buffer:",
          appState.positionBuffer.length,
          "points"
        );
      }

      // Erreur GPS
      function handleGPSError(error) {
        console.error("‚ùå Erreur GPS:", error);
        let message = "Erreur GPS inconnue";

        switch (error.code) {
          case error.PERMISSION_DENIED:
            message = "Permission GPS refus√©e";
            break;
          case error.POSITION_UNAVAILABLE:
            message = "Position indisponible";
            break;
          case error.TIMEOUT:
            message = "Timeout GPS";
            break;
        }

        updateGPSStatus(message, "text-red-400");
        document.getElementById("gps-indicator").className =
          "w-3 h-3 bg-red-400 rounded-full";
      }

      // ===== CALCULS DE DISTANCE ET PRIX =====

      // Calculer distance totale du trip
      function calculateTripDistance() {
        if (appState.tripPoints.length < 2) return 0;

        let totalDistance = 0;
        for (let i = 1; i < appState.tripPoints.length; i++) {
          const prev = appState.tripPoints[i - 1];
          const curr = appState.tripPoints[i];
          totalDistance += calculateDistance(
            prev.lat,
            prev.lng,
            curr.lat,
            curr.lng
          );
        }

        return totalDistance / 1000; // en kilom√®tres
      }

      // Estimer prix d'une course
      function estimatePrice(distanceKm, durationMin, zone = "default") {
        const pricing = PRICING_ZONES[zone] || PRICING_ZONES.default;

        const basePrice = pricing.base;
        const distancePrice = distanceKm * pricing.perKm;
        const timePrice = durationMin * pricing.perMin;

        return Math.round(basePrice + distancePrice + timePrice);
      }

      // D√©tecter zone tarifaire (simulation basique)
      function detectPricingZone(lat, lng) {
        // Utiliser la d√©tection de zone existante
        const zoneInfo = detectCurrentZone(lat, lng);

        if (!zoneInfo.authorized) {
          return "hors-zone"; // Tarif major√© hors zone
        }

        // Tarifs selon le quartier √† Pointe-Noire
        switch (zoneInfo.district) {
          case "Centre-ville":
            return "centre-ville";
          case "Ti√©-Ti√©":
            return "banlieue";
          case "Loandjili":
            return "port";
          case "Ngoyo":
            return "aeroport";
          default:
            return "default";
        }
      }

      // ===== D√âTECTION DE FRAUDE =====

      // Ajouter alerte fraude
      function addFraudAlert(message) {
        appState.suspiciousEvents.push({
          message,
          timestamp: Date.now(),
          position: appState.currentPosition,
        });

        // R√©duire score de confiance
        appState.trustScore = Math.max(0, appState.trustScore - 5);
        updateTrustScore();

        // Afficher alerte
        showFraudAlert(message);

        console.warn("üö® FRAUDE D√âTECT√âE:", message);
      }

      // Afficher alerte fraude
      function showFraudAlert(message) {
        document.getElementById("fraud-message").textContent = message;
        document.getElementById("fraud-alerts").classList.remove("hidden");

        setTimeout(() => {
          document.getElementById("fraud-alerts").classList.add("hidden");
        }, 5000);
      }

      // ===== INTERFACE UTILISATEUR =====

      // Mettre √† jour affichage GPS
      function updateGPSDisplay(point) {
        console.log("üñ•Ô∏è Mise √† jour UI GPS");
        document.getElementById("gps-accuracy").textContent = `${Math.round(
          point.accuracy || 0
        )}m`;
        document.getElementById("gps-speed").textContent = `${Math.round(
          (point.speed || 0) * 3.6
        )} km/h`;
        document.getElementById("points-count").textContent =
          appState.positionBuffer.length;
        document.getElementById(
          "last-position"
        ).textContent = `${point.lat.toFixed(4)}, ${point.lng.toFixed(4)}`;
      }

      // Mettre √† jour statut GPS
      function updateGPSStatus(status, colorClass) {
        const statusEl = document.getElementById("gps-status");
        statusEl.textContent = status;
        statusEl.className = `${colorClass} text-sm`;
        console.log("üìä Statut GPS:", status);
      }

      // Mettre √† jour distance du trip
      function updateTripDistance() {
        const distance = calculateTripDistance();
        document.getElementById(
          "current-distance"
        ).textContent = `${distance.toFixed(2)} km`;

        // Mettre √† jour prix estim√©
        const duration = (Date.now() - appState.tripStartTime) / 60000;
        const zone = appState.currentPosition
          ? detectPricingZone(
              appState.currentPosition.lat,
              appState.currentPosition.lng
            )
          : "default";
        const estimatedPrice = estimatePrice(distance, duration, zone);

        document.getElementById(
          "estimated-current-price"
        ).textContent = `${estimatedPrice} FCFA`;

        // V√©rifier √©cart prix
        const declaredPrice = appState.currentTrip.amount;
        const priceDiff =
          Math.abs(declaredPrice - estimatedPrice) / estimatedPrice;

        if (priceDiff > 0.3) {
          // 30% d'√©cart
          addFraudAlert(
            `√âcart prix suspect: ${declaredPrice} vs ${estimatedPrice} FCFA estim√©`
          );
        }
      }

      // Mettre √† jour score de confiance
      function updateTrustScore() {
        document.getElementById(
          "trust-score"
        ).textContent = `${appState.trustScore}%`;
        document.getElementById(
          "trust-bar"
        ).style.width = `${appState.trustScore}%`;

        const scoreEl = document.getElementById("trust-score");
        const barEl = document.getElementById("trust-bar");

        if (appState.trustScore >= 80) {
          scoreEl.className = "text-green-400 font-bold";
          barEl.className = "bg-green-400 h-2 rounded-full";
        } else if (appState.trustScore >= 60) {
          scoreEl.className = "text-yellow-400 font-bold";
          barEl.className = "bg-yellow-400 h-2 rounded-full";
        } else {
          scoreEl.className = "text-red-400 font-bold";
          barEl.className = "bg-red-400 h-2 rounded-full";
        }
      }

      // ===== INT√âGRATION AVEC L'APP EXISTANTE =====

      // DOM Elements
      const startDayBtn = document.getElementById("start-day-btn");
      const declareTripBtn = document.getElementById("declare-trip-btn");
      const pauseBtn = document.getElementById("pause-btn");
      const statusBadge = document.getElementById("status-badge");
      const tripModal = document.getElementById("trip-modal");
      const cameraModal = document.getElementById("camera-modal");
      const resultModal = document.getElementById("result-modal");
      const currentTripCard = document.getElementById("current-trip");

      // Camera permission check
      async function checkCameraPermission() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: true,
          });
          stream.getTracks().forEach((track) => track.stop());
          return true;
        } catch (err) {
          alert("‚ö†Ô∏è Cam√©ra non autoris√©e. Contactez votre propri√©taire.");
          return false;
        }
      }

      // Helpers to enable/disable buttons nicely
      function setButtonState(el, enabled) {
        el.disabled = !enabled;
        if (enabled) {
          el.classList.remove("opacity-50", "cursor-not-allowed");
        } else {
          if (!el.classList.contains("opacity-50"))
            el.classList.add("opacity-50");
          if (!el.classList.contains("cursor-not-allowed"))
            el.classList.add("cursor-not-allowed");
        }
      }

      function updateStatusBadge(text, colorClasses) {
        statusBadge.textContent = text;
        statusBadge.className =
          "px-3 py-1 rounded-full text-sm font-medium " + colorClasses;
      }

      // Start/End day toggle avec GPS
      startDayBtn.addEventListener("click", async () => {
        if (!appState.dayStarted) {
          const hasCamera = await checkCameraPermission();
          if (!hasCamera) return;

          // D√©marrer GPS
          if (!startGPSTracking()) {
            alert("‚ö†Ô∏è Impossible de d√©marrer le GPS. Fonctionnalit√© requise.");
            return;
          }

          appState.dayStarted = true;
          appState.paused = false;
          startDayBtn.textContent = "‚èπÔ∏è Terminer la journ√©e";
          startDayBtn.className =
            "w-full bg-red-600 hover:bg-red-700 text-white font-semibold py-4 px-6 rounded-xl transition-colors shadow-lg";

          setButtonState(declareTripBtn, true);
          setButtonState(pauseBtn, true);
          updateStatusBadge("En service", "bg-green-500 text-white");

          startPeriodicVerification();
        } else {
          // End day
          endDay();
        }
      });

      function endDay() {
        // Stop any current trip
        if (appState.currentTrip) {
          if (
            !confirm(
              "Une course est en cours. Voulez-vous vraiment terminer la journ√©e ?"
            )
          ) {
            return;
          }
          // Soft-reset current trip UI/state
          appState.currentTrip = null;
          appState.tripStartTime = null;
          appState.tripPoints = [];
          currentTripCard.classList.add("hidden");
        }

        // Arr√™ter GPS
        stopGPSTracking();

        appState.dayStarted = false;
        appState.paused = false;
        startDayBtn.textContent = "‚ñ∂Ô∏è D√©marrer la journ√©e";
        startDayBtn.className =
          "w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-4 px-6 rounded-xl transition-colors shadow-lg";

        setButtonState(declareTripBtn, false);
        setButtonState(pauseBtn, false);
        updateStatusBadge("Libre", "bg-yellow-500 text-black");

        stopPeriodicVerification();

        // Stop camera if left on
        try {
          if (appState.cameraStream) {
            appState.cameraStream.getTracks().forEach((t) => t.stop());
            appState.cameraStream = null;
          }
        } catch {}
      }

      // Pause/Resume toggle
      pauseBtn.addEventListener("click", () => {
        if (!appState.dayStarted) return;

        appState.paused = !appState.paused;

        if (appState.paused) {
          pauseBtn.textContent = "‚ñ∂Ô∏è Reprendre";
          updateStatusBadge("En pause", "bg-orange-500 text-white");
          setButtonState(declareTripBtn, false);
          stopPeriodicVerification();
        } else {
          pauseBtn.textContent = "‚è∏Ô∏è Pause";
          updateStatusBadge("En service", "bg-green-500 text-white");
          setButtonState(declareTripBtn, true);
          startPeriodicVerification();
        }
      });

      // Declare trip avec estimation prix
      declareTripBtn.addEventListener("click", () => {
        if (!appState.dayStarted || appState.paused) return;

        // Estimer prix bas√© sur position actuelle
        if (appState.currentPosition) {
          const zone = detectPricingZone(
            appState.currentPosition.lat,
            appState.currentPosition.lng
          );
          const baseEstimate = PRICING_ZONES[zone].base;
          document.getElementById(
            "estimated-price"
          ).textContent = `${baseEstimate}+ FCFA (base ${zone})`;
        }

        tripModal.classList.remove("hidden");
        tripModal.classList.add("flex");
        // Reset inputs
        document.getElementById("trip-amount").value = "";
        document.getElementById("passenger-count").value = "1";
      });

      // Cancel trip declaration
      document.getElementById("cancel-trip").addEventListener("click", () => {
        tripModal.classList.add("hidden");
        tripModal.classList.remove("flex");
      });

      // Start trip with verification
      document
        .getElementById("start-trip")
        .addEventListener("click", async () => {
          const amount = document.getElementById("trip-amount").value;
          const passengers = document.getElementById("passenger-count").value;

          if (!amount) {
            alert("Veuillez saisir le montant");
            return;
          }

          appState.currentTrip = {
            amount: parseInt(amount),
            passengers: parseInt(passengers),
            startPosition: appState.currentPosition,
            startTime: Date.now(),
          };

          // R√©initialiser points du trip
          appState.tripPoints = [];
          if (appState.currentPosition) {
            appState.tripPoints.push(appState.currentPosition);
          }

          tripModal.classList.add("hidden");
          tripModal.classList.remove("flex");

          // Start camera verification
          await startCameraVerification();
        });

      // Camera verification
      async function startCameraVerification() {
        cameraModal.classList.remove("hidden");
        cameraModal.classList.add("flex");

        // Reset overlay/message each time
        document.getElementById("verification-message").textContent =
          "V√©rification dans ";
        document.getElementById("countdown").textContent = "5";
        const overlay = document.getElementById("skeleton-overlay");
        overlay.classList.add("hidden");

        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: true,
          });
          const video = document.getElementById("camera-feed");
          video.srcObject = stream;
          appState.cameraStream = stream;

          // Countdown
          let countdown = 5;
          const countdownEl = document.getElementById("countdown");
          const interval = setInterval(() => {
            countdown--;
            countdownEl.textContent = String(countdown);
            if (countdown <= 0) {
              clearInterval(interval);
              captureAndAnalyze();
            }
          }, 1000);
        } catch (err) {
          alert("Erreur cam√©ra: " + err.message);
          cameraModal.classList.add("hidden");
          cameraModal.classList.remove("flex");
        }
      }

      // Capture and analyze
      async function captureAndAnalyze() {
        document.getElementById("verification-message").textContent =
          "Analyse en cours...";
        const overlay = document.getElementById("skeleton-overlay");
        overlay.classList.remove("hidden");

        // Simulate AI analysis
        setTimeout(() => {
          const declaredPassengers = appState.currentTrip.passengers;
          const detectedPassengers =
            Math.random() > 0.3 ? declaredPassengers : declaredPassengers + 2; // 70% chance correct

          // Stop camera
          try {
            if (appState.cameraStream) {
              appState.cameraStream
                .getTracks()
                .forEach((track) => track.stop());
              appState.cameraStream = null;
            }
          } catch {}

          cameraModal.classList.add("hidden");
          cameraModal.classList.remove("flex");
          overlay.classList.add("hidden");
          showVerificationResult(declaredPassengers, detectedPassengers);
        }, 2000);
      }

      // Show verification result
      function showVerificationResult(declared, detected) {
        const resultIcon = document.getElementById("result-icon");
        const resultTitle = document.getElementById("result-title");
        const resultMessage = document.getElementById("result-message");

        if (Math.abs(declared - detected) <= 1) {
          // Success
          resultIcon.textContent = "‚úÖ";
          resultTitle.textContent = "V√©rification r√©ussie";
          resultMessage.textContent = `${detected} passager(s) d√©tect√©(s) - Conforme √† la d√©claration`;

          // Start trip
          startTrip();
        } else {
          // Alert
          resultIcon.textContent = "‚ö†Ô∏è";
          resultTitle.textContent = "√âcart d√©tect√©";
          resultMessage.textContent = `${detected} passager(s) d√©tect√©(s) vs ${declared} d√©clar√©(s) - Alerte envoy√©e au propri√©taire`;

          // Add fraud alert
          addFraudAlert(
            `√âcart passagers: ${detected} d√©tect√©s vs ${declared} d√©clar√©s`
          );

          // Cancel currentTrip if verification failed
          appState.currentTrip = null;
          appState.tripPoints = [];
        }

        resultModal.classList.remove("hidden");
        resultModal.classList.add("flex");
      }

      // Close result modal
      document.getElementById("close-result").addEventListener("click", () => {
        resultModal.classList.add("hidden");
        resultModal.classList.remove("flex");
      });

      // Start trip avec sauvegarde
      async function startTrip() {
        appState.tripStartTime = Date.now();

        try {
          const savedTrip = await tripRepository.save({
            amount: appState.currentTrip.amount,
            passengers: appState.currentTrip.passengers,
            startPosition: appState.currentPosition,
            startTime: appState.tripStartTime,
            status: "active",
          });
          appState.currentTrip.id = savedTrip.id;
          console.log("üíæ Course sauvegard√©e:", savedTrip.id);
        } catch (error) {
          console.error("‚ùå Erreur sauvegarde:", error);
        }

        // Update UI (reste identique)
        document.getElementById("current-amount").textContent =
          appState.currentTrip.amount.toLocaleString() + " FCFA";
        document.getElementById("current-distance").textContent = "0.0 km";
        document.getElementById("estimated-current-price").textContent = "-";

        currentTripCard.classList.remove("hidden");
        updateStatusBadge("En course", "bg-blue-500 text-white");
        startTripTimer();
        stopPeriodicVerification();
      }
      // Trip timer
      function startTripTimer() {
        const timer = setInterval(() => {
          if (!appState.tripStartTime) {
            clearInterval(timer);
            return;
          }
          const elapsed = Date.now() - appState.tripStartTime;
          const minutes = Math.floor(elapsed / 60000);
          const seconds = Math.floor((elapsed % 60000) / 1000);
          document.getElementById("trip-duration").textContent = `${minutes
            .toString()
            .padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
        }, 1000);
      }

      // End trip avec sauvegarde automatique
      document
        .getElementById("end-trip-btn")
        .addEventListener("click", async () => {
          if (!appState.currentTrip) return;

          // Analyse finale de la course
          const finalDistance = calculateTripDistance();
          const finalDuration = (Date.now() - appState.tripStartTime) / 60000;
          const zone = appState.currentPosition
            ? detectPricingZone(
                appState.currentPosition.lat,
                appState.currentPosition.lng
              )
            : "default";
          const finalEstimatedPrice = estimatePrice(
            finalDistance,
            finalDuration,
            zone
          );
          try {
            // Mettre √† jour la course dans la base
            await tripRepository.update(appState.currentTrip.id, {
              endPosition: appState.currentPosition,
              distance: finalDistance,
              duration: finalDuration * 60000, // en millisecondes
              zone: zone,
              estimatedPrice: finalEstimatedPrice,
              status: "completed",
            });
            // Mettre √† jour les statistiques quotidiennes
            const todayStats = await statsRepository.getOrCreateToday();
            todayStats.updateFromTrip({
              amount: appState.currentTrip.amount,
              distance: finalDistance,
              duration: finalDuration * 60000,
              zone: zone,
              fraudAlerts: appState.suspiciousEvents.filter(
                (e) => e.timestamp > appState.tripStartTime
              ),
            });
            await statsRepository.save(todayStats);

            console.log("üíæ Course termin√©e et sauvegard√©e");
          } catch (error) {
            console.error("‚ùå Erreur sauvegarde fin de course:", error);
          }
          // Update earnings (interface seulement)
          appState.dailyEarnings += appState.currentTrip.amount;
          appState.tripCount++;

          document.getElementById("daily-earnings").textContent =
            appState.dailyEarnings.toLocaleString();
          document.getElementById("trip-count").textContent =
            appState.tripCount;

          // Reset trip
          appState.currentTrip = null;
          appState.tripStartTime = null;
          appState.tripPoints = [];

          currentTripCard.classList.add("hidden");
          updateStatusBadge(
            appState.dayStarted ? "En service" : "Libre",
            appState.dayStarted
              ? "bg-green-500 text-white"
              : "bg-yellow-500 text-black"
          );
          // Resume periodic verification if day is on and not paused
          startPeriodicVerification();
        });

      // Periodic verification when free
      function startPeriodicVerification() {
        stopPeriodicVerification(); // ensure single timer
        if (!appState.dayStarted || appState.currentTrip || appState.paused)
          return;

        appState.periodicTimerId = setTimeout(async () => {
          if (!appState.dayStarted || appState.currentTrip || appState.paused) {
            startPeriodicVerification();
            return;
          }

          // Silent verification
          try {
            const stream = await navigator.mediaDevices.getUserMedia({
              video: true,
            });

            // Simulate detection
            setTimeout(() => {
              const detected = Math.random() > 0.9 ? 2 : 0; // 10% fraud chance

              if (detected >= 2) {
                addFraudAlert("Transport non d√©clar√© d√©tect√©");
              }

              try {
                stream.getTracks().forEach((track) => track.stop());
              } catch {}
              startPeriodicVerification(); // Continue cycle
            }, 1000);
          } catch (err) {
            console.log("Periodic verification failed:", err);
            startPeriodicVerification(); // Continue cycle
          }
        }, 8 * 60 * 1000); // 8 minutes
      }

      function stopPeriodicVerification() {
        if (appState.periodicTimerId) {
          clearTimeout(appState.periodicTimerId);
          appState.periodicTimerId = null;
        }
      }

      // Service Worker Registration avec code inline
      if ("serviceWorker" in navigator) {
        const swCode = `
                                                                                    const CACHE_NAME = 'taxitracker-v2';
                                                                                    const urlsToCache = ['/'];

                                                                                    self.addEventListener('install', (event) => {
                                                                                      event.waitUntil(
                                                                                        caches.open(CACHE_NAME)
                                                                                          .then((cache) => cache.addAll(urlsToCache))
                                                                                      );
                                                                                    });

                                                                                    self.addEventListener('fetch', (event) => {
                                                                                      event.respondWith(
                                                                                        caches.match(event.request)
                                                                                          .then((response) => response || fetch(event.request))
                                                                                      );
                                                                                    });
                                                                                  `;

        const blob = new Blob([swCode], { type: "application/javascript" });
        const swUrl = URL.createObjectURL(blob);

        navigator.serviceWorker
          .register(swUrl)
          .then((registration) => console.log("SW registered"))
          .catch((error) => console.log("SW registration failed:", error));
      }

      // Test GPS simple au chargement
      function testGPSAvailability() {
        if (!navigator.geolocation) {
          console.error("‚ùå Geolocation non disponible");
          return;
        }

        console.log("üîç Test GPS au chargement...");
        navigator.geolocation.getCurrentPosition(
          (position) => {
            console.log("‚úÖ GPS fonctionne:", {
              lat: position.coords.latitude.toFixed(6),
              lng: position.coords.longitude.toFixed(6),
              accuracy: Math.round(position.coords.accuracy),
            });
          },
          (error) => {
            console.warn("‚ö†Ô∏è GPS non accessible:", error.message);
          },
          { timeout: 10000, maximumAge: 60000 }
        );
      }

      // Initialize app
      document.addEventListener("DOMContentLoaded", () => {
        console.log("üöÄ TaxiTracker avec GPS charg√©");

        simulateParisRoute();
        // simulateParisRouteMultiWaypointsDetailed();

        document
          .getElementById("zoom-in")
          .addEventListener("click", () => manualZoom("in"));
        document
          .getElementById("zoom-out")
          .addEventListener("click", () => manualZoom("out"));
        document
          .getElementById("zoom-ville")
          .addEventListener("click", () => applyZoom("ville"));
        document
          .getElementById("zoom-quartier")
          .addEventListener("click", () => applyZoom("quartier"));
        document
          .getElementById("zoom-rue")
          .addEventListener("click", () => applyZoom("rue"));

        // Mettre √† jour les statistiques quotidiennes
        async function updateDailyStats() {
          try {
            const todayStats = await statsRepository.getOrCreateToday();

            // Mettre √† jour l'affichage
            document.getElementById("daily-earnings").textContent =
              todayStats.totalEarnings.toLocaleString();
            document.getElementById("trip-count").textContent =
              todayStats.tripCount;

            console.log("üìä Stats mises √† jour:", todayStats.date);
          } catch (error) {
            console.error("‚ùå Erreur stats:", error);
          }
        }

        // Appeler au chargement
        updateDailyStats();

        // Test GPS disponibilit√©
        if (navigator.geolocation) {
          console.log("‚úÖ API Geolocation disponible");
          testGPSAvailability();
        } else {
          console.error("‚ùå API Geolocation non disponible");
        }

        // Assurer l'√©tat visuel initial des boutons
        setButtonState(declareTripBtn, false);
        setButtonState(pauseBtn, false);
        pauseBtn.textContent = "‚è∏Ô∏è Pause";

        // Initialiser affichage GPS
        updateGPSStatus("D√©sactiv√©", "text-red-400");

        // √âv√©nements carte
        document
          .getElementById("toggle-map")
          .addEventListener("click", toggleMap);
        document
          .getElementById("center-map")
          .addEventListener("click", centerMap);
        document
          .getElementById("clear-map")
          .addEventListener("click", clearMap);

        // D√©marrer le monitoring des zones
        startZoneMonitoring();

        // Test initial de zone si GPS d√©j√† disponible
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            (position) => {
              detectCurrentZone(
                position.coords.latitude,
                position.coords.longitude
              );
              updateZoneDisplay();
              console.log("üåç Zone initiale d√©tect√©e");
            },
            (error) => {
              console.log(
                "‚ö†Ô∏è Impossible de d√©tecter la zone initiale:",
                error.message
              );
            },
            { timeout: 5000, maximumAge: 60000 }
          );
        }
      });
    </script>
    <script>
      (function () {
        function c() {
          var b = a.contentDocument || a.contentWindow.document;
          if (b) {
            var d = b.createElement("script");
            d.innerHTML =
              "window.__CF$cv$params={r:'9872c26226e503fd',t:'MTc1OTIyNTIzMS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";
            b.getElementsByTagName("head")[0].appendChild(d);
          }
        }
        if (document.body) {
          var a = document.createElement("iframe");
          a.height = 1;
          a.width = 1;
          a.style.position = "absolute";
          a.style.top = 0;
          a.style.left = 0;
          a.style.border = "none";
          a.style.visibility = "hidden";
          document.body.appendChild(a);
          if ("loading" !== document.readyState) c();
          else if (window.addEventListener)
            document.addEventListener("DOMContentLoaded", c);
          else {
            var e = document.onreadystatechange || function () {};
            document.onreadystatechange = function (b) {
              e(b);
              "loading" !== document.readyState &&
                ((document.onreadystatechange = e), c());
            };
          }
        }
      })();
    </script>
  </body>
</html>
